#include <stdio.h>
#include <string.h>		/* for strdup */
#include <stdlib.h>		/* for free */
#include <errno.h>
#include <assert.h>

/* config.h.  Generated by configure.  */
/* config.h.in.  Generated from configure.in by autoheader.  */

#ifndef _CP_CONFIG_H
#define _CP_CONFIG_H

/* no multiple values */
/* #undef CP_HASHLIST_MUTLIPLE_VALUES */

/* no multiple values */
/* #undef CP_HASHTABLE_MUTLIPLE_VALUES */

/* Define to 1 if you have the <dirent.h> header file. */
#define CP_HAS_DIRENT_H 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define CP_HAS_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef CP_HAS_DOPRNT */

/* Define to 1 if you have the <fcntl.h> header file. */
#define CP_HAS_FCNTL_H 1

/* Define to 1 if you have the `gethostname' function. */
#define CP_HAS_GETHOSTNAME 1

/* Define to 1 if you have the `gettimeofday' function. */
#define CP_HAS_GETTIMEOFDAY 1

/* Define to 1 if you have the `read' function. */
#define CP_HAS_READ 1

/* Define to 1 if you have the `write' function. */
#define CP_HAS_WRITE 1

/* Define to 1 if you have the `inet_ntoa' function. */
#define CP_HAS_INET_NTOA 1

/* Define to 1 if you have the `inet_ntop' function. */
#define CP_HAS_INET_NTOP 1

/* Define to 1 if you have the <inttypes.h> header file. */
/* #undef CP_HAS_INTTYPES_H */

/* Define to 1 if you have the `dl' library (-ldl). */
/* #undef CP_HAS_LIBDL */

/* Define to 1 if you have the <memory.h> header file. */
/* #undef CP_HAS_MEMORY_H */

/* Define to 1 if you have the `memset' function. */
#define CP_HAS_MEMSET 1

/* Define to 1 if you have the <netdb.h> header file. */
#define CP_HAS_NETDB_H 1

/* Define to 1 if you have the <netinet/in.h> header file. */
#define CP_HAS_NETINET_IN_H 1

/* Define to 1 if you have the <pthread.h> header file. */
#define CP_HAS_PTHREAD_H 1

/* Define to 1 if PTHREAD_MUTEX_RECURSIVE works */
#define CP_HAS_PTHREAD_MUTEX_RECURSIVE 1

/* Define to 1 if PTHREAD_MUTEX_RECURSIVE doesn't work but
 * PTHREAD_MUTEX_RECURSIVE_NP does
 */
/* #undef CP_HAS_PTHREAD_MUTEX_RECURSIVE_NP */

/* Define to 1 if you have the `regcomp' function. */
#define CP_HAS_REGCOMP 1

/* Define to 1 if you have the <regex.h> header file. */
#define CP_HAS_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define CP_HAS_SELECT 1

/* Define to 1 if you have the `poll' function. */
#define CP_HAS_POLL 1

/* Define to 1 if you have the `socket' function. */
#define CP_HAS_SOCKET 1

/* Define to 1 if you have the <stdarg.h> header file. */
#define CP_HAS_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
/* #undef CP_HAS_STDINT_H */

/* Define to 1 if you have the <stdlib.h> header file. */
/* #undef CP_HAS_STDLIB_H */

/* Define to 1 if you have the `strlcat' function. */
/* #undef CP_HAS_STRLCAT */

/* Define to 1 if you have the `strlcpy' function. */
/* #undef CP_HAS_STRLCPY */

/* Define to 1 if you have the `strcasecmp' function. */
#define CP_HAS_STRCASECMP 1

/* Define to 1 if you have the `strdup' function. */
#define CP_HAS_STRDUP 1

/* Define to 1 if you have the `strftime' function. */
/* #undef CP_HAS_STRFTIME */

/* Define to 1 if you have the <strings.h> header file. */
/* #undef CP_HAS_STRINGS_H */

/* Define to 1 if you have the <string.h> header file. */
/* #undef CP_HAS_STRING_H */

/* Define to 1 if you have the `strndup' function. */
#define CP_HAS_STRNDUP 1

/* Define to 1 if you have the `strstr' function. */
#define CP_HAS_STRSTR 1

/* Define to 1 if you have the `strerror_r' function. */
#define CP_HAS_STRERROR_R 1

/* Define to 1 if you have the `getopt' function. */
#define CP_HAS_GETOPT 1

/* Define to 1 if you have the `getaddrinfo' function. */
#define CP_HAS_GETADDRINFO 1

/* Define to 1 if you have the `addrinfo' struct. */
#define CP_HAS_ADDRINFO 1

/* Define to 1 if you have the `getcwd' function. */
#define CP_HAS_GETCWD 1

/* Define to 1 if you have the `gmtime_r' function. */
#define CP_HAS_GMTIME_R 1

/* Define to 1 if you have the `localtime_r' function. */
#define CP_HAS_LOCALTIME_R 1

/* Define to 1 if you have the `pthread_getunique_np' function. */
/* #undef CP_HAS_PTHREAD_GETUNIQUE_NP */

/* Define to 1 if you have the `random' function. */
#define CP_HAS_RANDOM 1

/* Define to 1 if you have the `srandom' function. */
#define CP_HAS_SRANDOM 1

/* Define to 1 if you have the `stat' function. */
#define CP_HAS_STAT 1

/* Define to 1 if you have the `strncasecmp' function. */
#define CP_HAS_STRNCASECMP 1

/* Define to 1 if you have the `strptime' function. */
#define CP_HAS_STRPTIME 1

/* Define to 1 if you have the <sys/select> header file. */
#define CP_HAS_SYS_SELECT_H 1

/* Define to 1 if you have the `sigaction' function. */
#define CP_HAS_SIGACTION 1

/* Define to 1 if you have the `snprintf' function. */
#define CP_HAS_SNPRINTF 1

/* Define to 1 if you have the `vsprintf' function. */
#define CP_HAS_VSPRINTF 1

/* Define to 1 if you have the `vsnprintf' function. */
#define CP_HAS_VSNPRINTF 1

/* Define to 1 if you have the `getpagesize' function. */
#define CP_HAS_GETPAGESIZE 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define CP_HAS_DLFCN_H 1

/* Define to 1 if you have the <sys/socket.h> header file. */
#define CP_HAS_SYS_SOCKET_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
/* #undef CP_HAS_SYS_STAT_H */

/* Define to 1 if you have the <sys/time.h> header file. */
#define CP_HAS_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
/* #undef CP_HAS_SYS_TYPES_H */

/* Define to 1 if you have the <unistd.h> header file. */
#define CP_HAS_UNISTD_H 1

/* Define to 1 if you have the `vprintf' function. */
/* #undef CP_HAS_VPRINTF */

/* Define to 1 if supporting http cookies */
#define CP_USE_COOKIES 1

/* Define to 1 if supporting cpsp */
#define CP_USE_CPSP 1

/* Define to 1 if supporting http sessions */
#define CP_USE_HTTP_SESSIONS 1

/* Define to 1 if compiling with OpenSSL support */
#define CP_USE_SSL 1

/* Define to 1 if linking dbms libraries statically */
/* #undef CP_DBMS_STATIC */

/* Define to 1 if long long is supported */
#define CP_HAS_LONG_LONG 1

/* Define to 1 if variadic macros are supported */
#define CP_HAS_VARIADIC_MACROS 1

/* Define to 1 if hardware byte order is little endian */
/* #undef CP_BYTE_ORDER_LITTLE_ENDIAN */

#endif /* _CP_CONFIG_H */
#ifndef _CP_COMMON_H
#define _CP_COMMON_H

/** @{ */
/**
 * @file
 * common symbols for cprops library -- mostly error codes
 */

#ifdef	__cplusplus
#ifndef __BEGIN_DECLS
#define __BEGIN_DECLS	extern "C" {
#endif
#ifndef __END_DECLS
#define __END_DECLS	}
#endif
#else
#ifndef __BEGIN_DECLS
#define __BEGIN_DECLS
#endif
#ifndef __END_DECLS
#define __END_DECLS
#endif
#endif

#if defined(linux) || defined(__linux__) || defined (__linux) || defined(__gnu_linux__)
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif /* _GNU_SOURCE */
#endif /* linux */

#ifdef __NetBSD__
#ifndef __unix__
#define __unix__ 1
#endif /* __unix__ */
#endif /* __NetBSD__ */

#ifdef _WINDOWS

/* compatibility definitions */
typedef int pid_t;

#define SHUT_RD 	SD_RECEIVE
#define SHUT_WR 	SD_SEND
#define SHUT_RDWR 	SD_BOTH

#define close closesocket

#ifdef CPROPS_EXPORTS
#define CPROPS_DLL __declspec(dllexport)
#else
#define CPROPS_DLL __declspec(dllimport)
#endif
#else /* _WINDOWS */
#define CPROPS_DLL
#endif /* _WINDOWS */

#if (defined linux || defined __linux || defined __gnu_linux__)

#ifndef _REENTRANT
#define _REENTRANT
#endif

/* for pthread_rwlock_t et al. */
#ifndef _XOPEN_SOURCE 
#define _XOPEN_SOURCE 600
#endif
#ifndef __USE_UNIX98
#define __USE_UNIX98
#endif

#include <features.h>

#endif

#define DEFAULT_LOGFILE                                    "cp.log"
#if defined(unix) || defined(__unix__) || defined(__MACH__)
#define DEFAULT_TIME_FORMAT                                "%Y-%m-%d %T"
#else
#define DEFAULT_TIME_FORMAT                                "%Y-%m-%d %H:%M:%S"
#endif /* unix */
        /* error codes */

#define CP_MEMORY_ALLOCATION_FAILURE                       10000
#define CP_INVALID_FUNCTION_POINTER                        10010
#define CP_THREAD_CREATION_FAILURE                         10020

#define CP_LOADLIB_FAILED                                  11010
#define CP_LOADFN_FAILED                                   11020
#define CP_MODULE_NOT_LOADED                               11030

#define CP_IO_ERROR                                        12000
#define CP_OPEN_PORT_FAILED                                12010
#define CP_HTTP_FETCH_FAILED                               12020
#define CP_INVALID_RESPONSE                                12030
#define CP_HTTP_EMPTY_REQUEST                              12100
#define CP_HTTP_INVALID_REQUEST_LINE                       12110
#define CP_HTTP_INVALID_STATUS_LINE                        12111
#define CP_HTTP_UNKNOWN_REQUEST_TYPE                       12120
#define CP_HTTP_INVALID_URI                                12130
#define CP_HTTP_INVALID_URL                                12131
#define CP_HTTP_VERSION_NOT_SPECIFIED                      12140
#define CP_HTTP_1_1_HOST_NOT_SPECIFIED                     12150
#define CP_HTTP_INCORRECT_REQUEST_BODY_LENGTH              12160
#define CP_SSL_CTX_INITIALIZATION_ERROR                    12200
#define CP_SSL_HANDSHAKE_FAILED                            12210
#define CP_SSL_VERIFICATION_ERROR                          12220

#define CP_LOG_FILE_OPEN_FAILURE                           13000
#define CP_LOG_NOT_OPEN                                    13010

#define CP_INVALID_VALUE                                   14000
#define CP_MISSING_PARAMETER                               14010
#define CP_BAD_PARAMETER_SET                               14020
#define CP_ITEM_EXISTS                                     14030
#define CP_UNHANDLED_SIGNAL                                14040
#define CP_FILE_NOT_FOUND                                  14050
#define CP_METHOD_NOT_IMPLEMENTED                          14060

#define CP_REGEX_COMPILATION_FAILURE                       15000
#define CP_COMPILATION_FAILURE                             15010

#define CP_DBMS_NO_DRIVER                                  16000
#define CP_DBMS_CONNECTION_FAILURE                         16010
#define CP_DBMS_QUERY_FAILED                               16020
#define CP_DBMS_CLIENT_ERROR                               16030
#define CP_DBMS_STATEMENT_ERROR                            16040

/** @} */

#endif






#ifndef _CP_COLLECTION_H
#define _CP_COLLECTION_H


__BEGIN_DECLS

#ifndef _CP_LOG_H
#define _CP_LOG_H

#ifndef _CP_STRING_H
#define _CP_STRING_H

/** @{ */
/**
 * @file
 * cp_string - 'safe' string allowing binary content 
 */

__BEGIN_DECLS

/** cp_string definition */
typedef CPROPS_DLL struct _cp_string
{
	int size;    /**< size allocated   */
	int len;     /**< size used        */
	char *data;  /**< internal buffer  */
} cp_string;

/** allocate a new cp_string */
CPROPS_DLL
cp_string *cp_string_create(char *data, int len);
/** allocate an empty cp_string with a given buffer size */
CPROPS_DLL
cp_string *cp_string_create_empty(int initial_size);
/** deallocate a cp_string */
CPROPS_DLL
void cp_string_delete(cp_string *str);
/* on windows, you can't just free memory allocated by code in a dll. If you
 * want to set up a string, then delete the string object wrapper and just use
 * the internal char *, you have to free the wrap with cp_string_drop_wrap() 
 * and free the char * with cp_string_drop_content.
 */
CPROPS_DLL
void cp_string_drop_wrap(cp_string *str);
CPROPS_DLL 
void cp_string_drop_content(char *content);

/** synonym for cp_string_delete */
CPROPS_DLL
void cp_string_destroy(cp_string *str);
/** sets string to 0 */
CPROPS_DLL
void cp_string_clear(cp_string *str);
/** releases existing string and sets string to empty string */
CPROPS_DLL
void cp_string_reset(cp_string *str);
/** copies the content of a null terminated c string */
CPROPS_DLL
cp_string *cp_string_cstrcpy(cp_string *str, char *cstr);
/** copies the content of a cp_string */
CPROPS_DLL
cp_string *cp_string_cpy(cp_string *dst, cp_string *src);
/** creates a copy of src string. internal buffer is duplicated. */
CPROPS_DLL
cp_string *cp_string_dup(cp_string *src);
/** creates a cp_string with src as its content */
CPROPS_DLL
cp_string *cp_string_cstrdup(char *src);
/** concatenate cp_strings */
CPROPS_DLL
cp_string *cp_string_cat(cp_string *str, cp_string *appendum);
/** append data from a buffer */
CPROPS_DLL
cp_string *cp_string_cat_bin(cp_string *str, void *bin, int len);
/** append data from a null terminated c string */
CPROPS_DLL
cp_string *cp_string_cstrcat(cp_string *str, char *cstr);
/** append a character to a string */
CPROPS_DLL
cp_string *cp_string_append_char(cp_string *str, char ch);
/** compare cp_strings */
CPROPS_DLL
int cp_string_cmp(cp_string *s1, cp_string *s2);
/** return a pointer to the internal buffer */
CPROPS_DLL
char *cp_string_tocstr(cp_string *str);
/** return the length of the internal buffer */
CPROPS_DLL
int cp_string_len(cp_string *s);

/** read len bytes from an open file descriptor (blocking) */
CPROPS_DLL
cp_string *cp_string_read(int fd, int len);
/** write the content of a cp_string to a file descriptor (blocking) */
CPROPS_DLL
int cp_string_write(cp_string *str, int fd);
/** read the contents of a file into a cp_string */
CPROPS_DLL
cp_string *cp_string_read_file(char *filename);
/** write the contents of a cp_string to a file */
CPROPS_DLL
int cp_string_write_file(cp_string *str, char *filename);

/** flip the contents of a cp_string */
CPROPS_DLL
void cp_string_flip(cp_string *str);
/** remove all occurrences of letters from str */
CPROPS_DLL
cp_string *cp_string_filter(cp_string *str, char *letters);

/** dump a cp_string to stdout */
CPROPS_DLL
void cp_string_dump(cp_string *str);

__END_DECLS

/** @} */

#endif


__BEGIN_DECLS


/** debug level */
#define LOG_LEVEL_DEBUG				0
/** normal log level */
#define LOG_LEVEL_INFO				1
/** relatively quiet - warnings only */
#define LOG_LEVEL_WARNING			2
/** quit - severe errors only */
#define LOG_LEVEL_ERROR				3
/** very quiet - report fatal errors only */
#define LOG_LEVEL_FATAL				4
/** no logging */
#define LOG_LEVEL_SILENT			5


#define cp_assert(cond) (cond == 0 ? die(1, "assertion %s failed, in %s line %d\n", #cond, __FILE__, __LINE__) : 0)

#ifdef __OpenBSD__
#define MAX_LOG_MESSAGE_LEN 0x1000
#else
#define MAX_LOG_MESSAGE_LEN 0x10000
#endif

/** precision of seconds: undefine or use 1-6 */
#define PRECISE_TIME "3" 
#ifdef PRECISE_TIME
#define PRECISE_TIME_FORMAT ".%0" PRECISE_TIME "ld"
#else		//precise
#define PRECISE_TIME_FORMAT ""
#endif	

CPROPS_DLL
int cp_log_init(char *filename, int verbosity);

CPROPS_DLL
int cp_log_reopen();

CPROPS_DLL
int cp_log_close();

CPROPS_DLL
void die(int code, const char *msg, ...);

CPROPS_DLL
void cp_log_set_time_format(char *time_format);

/**
 * unconditionally log a message
 */
CPROPS_DLL
void cp_log(const char *msg, ...);

/**
 * unconditionally log a limited length message
 */
CPROPS_DLL
void cp_nlog(size_t len, const char *msg, ...);

#ifdef CP_HAS_VARIADIC_MACROS
#define cp_debug(msg, ...) \
	(cp_debug_message(msg, __FILE__, __LINE__ , ## __VA_ARGS__))
CPROPS_DLL
void cp_debug_message(char *msg, char *file, int line, ...);
#else
CPROPS_DLL
void cp_debug(char *msg, ...);
#endif

CPROPS_DLL
void cp_debuginfo(char *msg, ...);

CPROPS_DLL
void cp_info(char *msg, ...);

/**
 * print out a LOG_LEVEL_WARNING log message 
 */
CPROPS_DLL
void cp_warn(char *msg, ...);

/**
 * print out a LOG_LEVEL_ERROR log message
 */
#ifdef CP_HAS_VARIADIC_MACROS
#define cp_error(code, msg, ...) \
		(cp_error_message(code, msg, __FILE__, __LINE__ , ## __VA_ARGS__))
CPROPS_DLL
void cp_error_message(int code, char *msg, char *file, int line, ...);
#else
CPROPS_DLL
void cp_error(int code, char *msg, ...);
#endif

/**
 * print out a LOG_LEVEL_ERROR log message with an errno code
 */
#ifdef CP_HAS_VARIADIC_MACROS
#define cp_perror(code, errno_code, msg, ...) \
		(cp_perror_message(code, errno_code, msg, __FILE__, __LINE__ , ## __VA_ARGS__))
CPROPS_DLL
void cp_perror_message(int code, int errno_code, 
                       char *msg, char *file, int line, ...);
#else
CPROPS_DLL
void cp_perror(int code, int errno_code, char *msg, ...);
#endif

/**
 * print out a LOG_LEVEL_FATAL log message and exit. if log_level is 
 * LOG_LEVEL_SILENT, the error message is supressed but the process still
 * exits.
 */
#ifdef CP_HAS_VARIADIC_MACROS
#define cp_fatal(code, msg, ...) \
		(cp_fatal_message(code, msg, __FILE__, __LINE__ , ## __VA_ARGS__))
CPROPS_DLL
void cp_fatal_message(int code, char *msg, char *file, int line, ...);
#else
CPROPS_DLL
void cp_fatal(int code, char *msg, ...);
#endif

/** hex dump a cp_string */
CPROPS_DLL
void cp_dump(int log_level, cp_string *str);

/** hex dump up to len bytes of a cp_string */
CPROPS_DLL
void cp_ndump(int log_level, cp_string *str, size_t len);

#ifdef DEBUG
#ifdef CP_HAS_VARIADIC_MACROS
#define DEBUGMSG(msg, ...) DEBUGMSG_impl(msg, __FILE__, __LINE__ , ## __VA_ARGS__)
CPROPS_DLL
void DEBUGMSG_impl(char *msg, char *file, int line, ...);
#else
CPROPS_DLL
void DEBUGMSG(char *msg, ...);
#endif
#else
#ifdef CP_HAS_VARIADIC_MACROS
#define DEBUGMSG(...)
#else
#define DEBUGMSG()
#endif
#endif

#if defined(CP_HAS_REGEX_H) || defined(CP_HAS_PCRE)
CPROPS_DLL
int log_regex_compilation_error(int rc, char *msg);
#endif /* CP_HAS_REGEX_H */

__END_DECLS

/** @} */

#endif


#ifdef CP_HAS_PTHREAD_H
#include <pthread.h>
#endif

/** use collection defaults */
#define COLLECTION_MODE_PLAIN             0
/** collection copies and deletes elements (keys, values) */
#define COLLECTION_MODE_DEEP              1
/** collection allows non-unique keys */
#define COLLECTION_MODE_MULTIPLE_VALUES   2
/** collection stores copies of elements (keys, values) */
#define COLLECTION_MODE_COPY              4
/** no synchronization - suitable for the single threaded situation or if you 
  * want to do the synchronization yourself. */
#define COLLECTION_MODE_NOSYNC            8
/** 
 * The collection does not resize underlying hashtables. It might make sense 
 * to set this temporarily in code sections that shouldn't be unexpectedly 
 * slowed down by a resize operation, but resize should be allowed if the 
 * table fill factor is expected to go over ~70%, which is the point at which
 * hashtable performace is rumored to start degrading. 
 */
#define COLLECTION_MODE_NORESIZE         16
/**
 * hashlist multiple values are returned in list order (O(N)) rather than 
 * insertion order (O(1))
 */
#define COLLECTION_MODE_LIST_ORDER		 32
/**
 * indicates a transaction is in progress
 */
#define COLLECTION_MODE_IN_TRANSACTION   64

/** no lock */
#define COLLECTION_LOCK_NONE   0
/** lock for reading */
#define COLLECTION_LOCK_READ   1
/** lock for writing */
#define COLLECTION_LOCK_WRITE  2

/**
 * copy function.
 *
 * In cases where the collection holds copies rather than references to the
 * original objects. To do this you need to provide a copy function for
 * the items.
 */
typedef void *(*cp_copy_fn)(void *);

/**
 * destructor function.
 */
typedef void (*cp_destructor_fn)(void *);

/**
 * comparator functions implement strcmp semantics - 0 for identical keys, 
 * non-zero otherwise.
 */
typedef int (*cp_compare_fn)(void *, void *);

/**
 * callback function for iterator callback etc
 */
typedef int (*cp_callback_fn)(void *entry, void *client_prm);

/**
 * lock for collection types - current implementation uses pthread_rwlock_t
 *
 * _WINDOWS implementation for cp_cond is based on "Strategies for Implementing 
 * POSIX Condition Variables on _WINDOWS" by Douglas C. Schmidt and Irfan Pyarali
 * see http://www.cs.wustl.edu/~schmidt/_WINDOWS-cv-1.html
 */
#ifdef CP_HAS_PTHREAD_H
typedef pthread_t cp_thread;
typedef pthread_rwlock_t cp_lock;
typedef pthread_mutex_t cp_mutex;
typedef pthread_cond_t cp_cond;
#define cp_thread_create(thread, attr, fn, prm) pthread_create(&(thread), attr, fn, prm)
#define cp_thread_join pthread_join
#define cp_thread_detach pthread_detach
#define cp_thread_self pthread_self
#define cp_mutex_init pthread_mutex_init
#define cp_mutex_lock pthread_mutex_lock
#define cp_mutex_unlock pthread_mutex_unlock
#define cp_mutex_destroy pthread_mutex_destroy
#define cp_cond_init pthread_cond_init
#define cp_cond_wait pthread_cond_wait
#define cp_cond_signal pthread_cond_signal
#define cp_cond_broadcast pthread_cond_broadcast
#define cp_cond_destroy pthread_cond_destroy
#define cp_lock_init pthread_rwlock_init
#define cp_lock_rdlock pthread_rwlock_rdlock
#define cp_lock_wrlock pthread_rwlock_wrlock
#define cp_lock_unlock pthread_rwlock_unlock
#define cp_lock_destroy pthread_rwlock_destroy
#define cp_thread_equal pthread_equal
#ifndef CP_HAS_PTHREAD_MUTEX_RECURSIVE
#ifdef CP_HAS_PTHREAD_MUTEX_RECURSIVE_NP
#define CP_HAS_PTHREAD_MUTEX_RECURSIVE CP_HAS_PTHREAD_MUTEX_RECURSIVE_NP
#endif /* CP_HAS_PTHREAD_MUTEX_RECURSIVE_NP */
#endif /* CP_HAS_PTHREAD_MUTEX_RECURSIVE */
#else 
#ifdef _WINDOWS
typedef HANDLE cp_thread;
typedef HANDLE *cp_mutex;
#define cp_thread_create(thread, attr, fn, prm) \
	(((thread) = CreateThread(attr, 0, (LPTHREAD_START_ROUTINE) fn, prm, 0, NULL)) == NULL)
#define cp_thread_join(thread, exp) \
	{ \
		cp_thread p = thread; \
		WaitForSingleObject(p, INFINITE); \
	}
#define cp_thread_detach 
#define cp_thread_self GetCurrentThread
CPROPS_DLL
int cp_mutex_init(cp_mutex *mutex, void *attr);
#define cp_mutex_lock(mutex) (WaitForSingleObject((*(mutex)), INFINITE))
#define cp_mutex_unlock(mutex) (ReleaseMutex(*(mutex)))
#define cp_mutex_destroy(mutex) (CloseHandle(*(mutex)))

/* WIN32 implementation of a basic POSIX-condition-variable-like API
 * 
 * based on "Strategies for Implementing POSIX Condition Variables on WIN32"
 * by Douglas C. Schmidt and Irfan Pyarali - 
 * see http://www.cs.wustl.edu/~schmidt/WIN32-cv-1.html
 */
typedef CPROPS_DLL struct
{
  int waiters_count_;
  // Number of waiting threads.

  CRITICAL_SECTION waiters_count_lock_;
  // Serialize access to <waiters_count_>.

  HANDLE sema_;
  // Semaphore used to queue up threads waiting for the condition to
  // become signaled. 

  HANDLE waiters_done_;
  // An auto-reset event used by the broadcast/signal thread to wait
  // for all the waiting thread(s) to wake up and be released from the
  // semaphore. 

  size_t was_broadcast_;
  // Keeps track of whether we were broadcasting or signaling.  This
  // allows us to optimize the code if we're just signaling.
} cp_cond;

CPROPS_DLL int cp_cond_init(cp_cond *cv, const void *attr); // pthread_condattr_t *)
CPROPS_DLL int cp_cond_wait(cp_cond *cv, cp_mutex *mutex);
CPROPS_DLL int cp_cond_signal(cp_cond *cv);
CPROPS_DLL int cp_cond_broadcast(cp_cond *cv);
CPROPS_DLL int cp_cond_destroy(cp_cond *cv);

/* WIN32 implementation of a basic POSIX-read-write-lock-like API. cp_lock
 * is not upgradeable, ie attempting to obtain the lock if the current
 * thread already owns it causes deadlock.
 */
typedef CPROPS_DLL struct _cp_lock
{
	HANDLE access_mutex;
//	HANDLE write_mutex;

	DWORD writer;

	int readers;
	int writer_waiting;

} cp_lock;

CPROPS_DLL int cp_lock_init(cp_lock *lock, void *attr);
CPROPS_DLL int cp_lock_rdlock(cp_lock *lock);
CPROPS_DLL int cp_lock_wrlock(cp_lock *lock);
CPROPS_DLL int cp_lock_unlock(cp_lock *lock);
CPROPS_DLL int cp_lock_destroy(cp_lock *lock);

#define cp_thread_equal(p, q) ((p) == (q))
#endif
#endif

typedef CPROPS_DLL struct _cp_wrap
{
	void *item;
	cp_destructor_fn dtr;
} cp_wrap;

CPROPS_DLL cp_wrap *cp_wrap_new(void *item, cp_destructor_fn dtr);
CPROPS_DLL void cp_wrap_delete(cp_wrap *wrap);
	
typedef CPROPS_DLL struct _cp_mapping
{
	void *key;
	void *value;
} cp_mapping;

#define cp_mapping_key(m) 	((m)->key)
#define cp_mapping_value(m)	((m)->value)

typedef int (*cp_mapping_cmp_fn)(cp_mapping *a, cp_mapping *b);

/* free an allocation made by a cprops api function. On Windows you can't just
 * call free on memory allocated in a call to a DLL function.
 */
#ifdef _WINDOWS
CPROPS_DLL
void *cp_malloc(size_t size);
CPROPS_DLL
void *cp_calloc(size_t count, size_t size);
CPROPS_DLL 
void *cp_realloc(void *p, size_t size);
CPROPS_DLL
void cp_free(void *p);
#else
#define cp_malloc malloc
#define cp_calloc calloc
#define cp_realloc realloc
#define cp_free free
#endif /* _WINDOWS */

struct _cp_mempool;
struct _cp_shared_mempool;

__END_DECLS

/** @} */

#endif





#ifndef _CP_VECTOR_H
#define _CP_VECTOR_H


__BEGIN_DECLS

/**
 * A simple 'safe array' implementation.
 */
typedef CPROPS_DLL struct _cp_vector
{
    void **mem;            		 /**< Pointer to memory               */
    int size;              		 /**< size of vector (element count)  */
    int head;              		 /**< index of 1st element            */
    int tail;              		 /**< index of Nth element            */

	int mode;              		 /**< collection mode                 */
	cp_copy_fn copy_item;        /**< item copy function              */
	cp_destructor_fn free_item;  /**< item destructor function        */
	cp_lock *lock;         		 /**< rwlock                          */
} cp_vector;

CPROPS_DLL
cp_vector *cp_vector_create_by_option(int size, 
									  int mode, 
									  cp_copy_fn copy_item,
									  cp_destructor_fn free_item);
CPROPS_DLL
cp_vector *cp_vector_create(int size);
CPROPS_DLL
cp_vector *cp_vector_wrap(void **data, int len, int mode);
CPROPS_DLL
void cp_vector_destroy(cp_vector *v);
CPROPS_DLL
void cp_vector_destroy_custom(cp_vector *v, cp_destructor_fn dtr);
CPROPS_DLL
void *cp_vector_add_element(cp_vector *v, void *element);
CPROPS_DLL
void *cp_vector_element_at(cp_vector *v, int index);
CPROPS_DLL
void *cp_vector_set_element(cp_vector *v, int index, void *element);
CPROPS_DLL
void cp_vector_remove_element(cp_vector *v, int index);
CPROPS_DLL
int cp_vector_size(cp_vector *v);

/* ----------------------------------------------------------------- */

__END_DECLS

/** @} */

#endif /* _COLLECTION_VECTOR_H */



#ifndef _CP_MEMPOOL_H
#define _CP_MEMPOOL_H

__BEGIN_DECLS

struct _cp_mempool;

typedef void (*cp_mempool_callback_fn)(void *prm, 
									   struct _cp_mempool *pool, 
									   void *mem);

typedef struct _cp_mempool
{
	size_t item_size;
	size_t alloc_size;
	size_t items_per_alloc;

	char *reuse_pool;
	char *alloc_pool;
	size_t alloc_pool_pos;

	int refcount;

	cp_mempool_callback_fn alloc_callback;
	void *callback_prm;

	int mode;
	cp_mutex *lock;
#if !defined(CP_HAS_PTHREAD_MUTEX_RECURSIVE) && !defined(CP_HAS_PTHREAD_MUTEX_RECURSIVE_NP)
    cp_thread txowner;
#endif /* CP_HAS_PTHREAD_MUTEX_RECURSIVE */
} cp_mempool;

#define cp_mempool_item_size(p) ((p)->item_size)

/* cp_mempool_create_by_option */
CPROPS_DLL
cp_mempool *cp_mempool_create_by_option(const int mode, 
                       		            size_t chunksize, 
                                    	size_t multiple);

/* cp_mempool_create_by_option */
CPROPS_DLL
cp_mempool *cp_mempool_create(const size_t chunksize);

/* increment refcount */
CPROPS_DLL
int cp_mempool_inc_refcount(cp_mempool *pool);

/* cp_mempool_alloc */
CPROPS_DLL
void *cp_mempool_alloc(cp_mempool * const pool);

/* cp_mempool_calloc */
CPROPS_DLL
void *cp_mempool_calloc(cp_mempool * const pool);

/* cp_mempool_free */
CPROPS_DLL
int cp_mempool_free(cp_mempool * const pool, void *data);

/* cp_mempool_destroy */
CPROPS_DLL
void cp_mempool_destroy(cp_mempool *pool);


#ifndef _CP_RB_H
#define _CP_RB_H

/** @{ */
/**
 * @file
 *
 * red-black tree definitions. Red-black trees are self balancing binary trees. 
 * red-black trees guarantee a O(log n) time for tree operations. An advantage
 * over AVL trees is in that insertion and deletion require a small number of 
 * rotations (2 or 3) at the most.
 *
 * First introduced by Rudolf Bayer in Symmetric Binary B-Trees: Data 
 * Structures and Maintenance Algorithms, 1972.
 * The 'red-black' terminology is due to Leo J. Guibas and Robert Sedgewick: 
 * A Dichromatic Framework for Balanced Trees, 1978.
 */


__BEGIN_DECLS


struct _cp_rbtree;

#define RB_RED    0
#define RB_BLACK  1

typedef CPROPS_DLL struct _cp_rbnode
{
	void *key;
	void *value;

	/* balance maintainance - color is either 'red' or 'black' */
	int color;

	struct _cp_rbnode *left;
	struct _cp_rbnode *right;
	struct _cp_rbnode *up;
} cp_rbnode;

/* (internal) allocate a new node */
CPROPS_DLL
cp_rbnode *cp_rbnode_create(void *key, void *value, struct _cp_mempool *pool);
/* (internal) deallocate a node */
CPROPS_DLL
void cp_rbtree_destroy_node(struct _cp_rbtree *owner, cp_rbnode *node);
/* (internal) deallocate a node and its subnodes */
CPROPS_DLL
void cp_rbtree_destroy_node_deep(struct _cp_rbtree *owner, cp_rbnode *node);

/* tree wrapper object */
typedef CPROPS_DLL struct _cp_rbtree
{

        //niloo
        int opCount;

	cp_rbnode *root;             /* root node */
	
	int items;                   /* item count */

	int mode;					 /* mode flags */
	cp_compare_fn cmp;           /* key comparison function */
	cp_copy_fn key_copy;         /* key copy function */
	cp_destructor_fn key_dtr;    /* key destructor */
	cp_copy_fn value_copy;       /* value copy function */
	cp_destructor_fn value_dtr;  /* value destructor */

	cp_lock *lock;
	cp_thread txowner;           /* set if a transaction is in progress */
	int txtype;                  /* lock type */

	cp_mempool *mempool; 		 /* optional memory pool */
} cp_rbtree;

/* 
 * default create function - equivalent to create_by_option with mode 
 * COLLECTION_MODE_NOSYNC
 */
CPROPS_DLL
cp_rbtree *cp_rbtree_create(cp_compare_fn cmp);
/*
 * complete parameter create function. Note that setting COLLECTION_MODE_COPY
 * without specifying a copy function for either keys or values will result in
 * keys or values respectively being inserted by value, with no copying 
 * performed. Similarly, setting COLLECTION_MODE_DEEP without specifying a 
 * destructor function for keys or values will result in no destructor call
 * for keys or values respectively. This allows using the copy/deep mechanisms
 * for keys only, values only or both.
 */
CPROPS_DLL
cp_rbtree *
	cp_rbtree_create_by_option(int mode, cp_compare_fn cmp, 
							   cp_copy_fn key_copy, cp_destructor_fn key_dtr,
							   cp_copy_fn val_copy, cp_destructor_fn val_dtr);
/* 
 * recursively destroy the tree structure 
 */
CPROPS_DLL
void cp_rbtree_destroy(cp_rbtree *tree);
/*
 * recursively destroy the tree structure with the given destructor functions
 */
CPROPS_DLL
void cp_rbtree_destroy_custom(cp_rbtree *tree, 
							  cp_destructor_fn key_dtr,
							  cp_destructor_fn val_dtr);

/* insertion function */
CPROPS_DLL
void *cp_rbtree_insert(cp_rbtree *tree, void *key, void *value);
/* retrieve the value mapped to the given key */
CPROPS_DLL
void *cp_rbtree_get(cp_rbtree *tree, void *key);
/* return non-zero if a mapping for 'key' could be found */
CPROPS_DLL
int cp_rbtree_contains(cp_rbtree *tree, void *key);
/* delete a mapping */
CPROPS_DLL
void *cp_rbtree_delete(cp_rbtree *tree, void *key);

/* 
 * perform a pre-order iteration over the tree, calling 'callback' on each 
 * node
 */
CPROPS_DLL
int cp_rbtree_callback_preorder(cp_rbtree *tree, 
								cp_callback_fn callback, 
								void *prm);
/* 
 * perform an in-order iteration over the tree, calling 'callback' on each 
 * node
 */
CPROPS_DLL
int cp_rbtree_callback(cp_rbtree *tree, cp_callback_fn callback, void *prm);
/* 
 * perform a post-order iteration over the tree, calling 'callback' on each 
 * node
 */

CPROPS_DLL
int cp_rbtree_callback_postorder(cp_rbtree *tree, 
								 cp_callback_fn callback, 
								 void *prm);

/* return the number of mappings in the tree */
CPROPS_DLL
int cp_rbtree_count(cp_rbtree *tree);

/* 
 * lock tree for reading or writing as specified by type parameter. 
 */
CPROPS_DLL
int cp_rbtree_lock(cp_rbtree *tree, int type);
/* read lock */
#define cp_rbtree_rdlock(tree) (cp_rbtree_lock((tree), COLLECTION_LOCK_READ))
/* write lock */
#define cp_rbtree_wrlock(tree) (cp_rbtree_lock((tree), COLLECTION_LOCK_WRITE))
/* unlock */
CPROPS_DLL
int cp_rbtree_unlock(cp_rbtree *tree);


/* return the table mode indicator */
CPROPS_DLL
int cp_rbtree_get_mode(cp_rbtree *tree);
/* set mode bits on the tree mode indicator */
CPROPS_DLL
int cp_rbtree_set_mode(cp_rbtree *tree, int mode);
/* unset mode bits on the tree mode indicator. if unsetting 
 * COLLECTION_MODE_NOSYNC and the tree was not previously synchronized, the 
 * internal synchronization structure is initalized.
 */
CPROPS_DLL
int cp_rbtree_unset_mode(cp_rbtree *tree, int mode);


/** print tree to stdout */
CPROPS_DLL
void cp_rbtree_dump(cp_rbtree *tree);

/* set tree to use given mempool or allocate a new one if pool is NULL */
CPROPS_DLL
int cp_rbtree_use_mempool(cp_rbtree *tree, cp_mempool *pool);

/* set tree to use a shared memory pool */
CPROPS_DLL
int cp_rbtree_share_mempool(cp_rbtree *tree, struct _cp_shared_mempool *pool);

__END_DECLS

/** @} */

#endif


#ifndef _CP_HASHTABLE_H
#define _CP_HASHTABLE_H

/*
 * hash table implementation
 */

/**
 * @addtogroup cp_hashtable
 * @ingroup collection
 * @copydoc collection
 *
 */
/** @{ */
__BEGIN_DECLS

/*
 * cp_hashtable interface for members of mapping collections.
 */

/**
 * 1000000001 is a prime. HASH_SEED is used by cp_hash_string(). 
 */
#define HASH_SEED 1000000001L

#ifndef CP_HASHTABLE_DEFAULT_MIN_FILL_FACTOR
#define CP_HASHTABLE_DEFAULT_MIN_FILL_FACTOR   5
#endif

#ifndef CP_HASHTABLE_DEFAULT_MAX_FILL_FACTOR
#define CP_HASHTABLE_DEFAULT_MAX_FILL_FACTOR  70
#endif

/* ----------------------------------------------------------------- 
 * Function prototypes
 * ----------------------------------------------------------------- */
/**
 * the hash function takes (void *) and returns unsigned long.
 *
 * Create a function with the name <class_name>_hash_code()
 */
typedef unsigned long (*cp_hashfunction)(void *);


/* ------------------------------------------------------------------------ 
 * hash function prototypes for primitives and cp_strings
 * ------------------------------------------------------------------------ */


/**
 * hash function for int keys
 * @param key pointer to the int
 * @return hash code of the key
 */
CPROPS_DLL 
unsigned long cp_hash_int(void *key);


/**
 * comparator for int keys
 * @param key1 pointer the first int
 * @param key2 pointer the second int
 * @retval 0 if key1 equals key2;
 * @retval <0 if key1 is less than key2;
 * @retval >0 if key1 is greater than key2

 */
CPROPS_DLL 
int cp_hash_compare_int(void *key1, void *key2);

/**
 * hash function for long keys
 */
CPROPS_DLL 
unsigned long cp_hash_long(void *key);

/**
 * comparator for long keys
 * 
 * @param key1 pointer the first long
 * @param key2 pointer the second long
 * @retval 0 if key1 equals key2;
 * @retval <0 if key1 is less than key2;
 * @retval >0 if key1 is greater than key2
 */
CPROPS_DLL 
int cp_hash_compare_long(void *key1, void *key2);

/**
 * hash function for pointer keys
 */
CPROPS_DLL 
unsigned long cp_hash_addr(void *addr);

/**
 * comparator for pointer keys
 * 
 * @param key1 pointer the first pointer
 * @param key2 pointer the second pointer
 * @retval 0 if key1 equals key2;
 * @retval <0 if key1 is less than key2;
 * @retval >0 if key1 is greater than key2
 */
CPROPS_DLL 
int cp_hash_compare_addr(void *key1, void *key2);

/**
 * hash function for (char *) keys
 * @param key pointer to the cp_string
 * @return hash code of the key
 */
CPROPS_DLL 
unsigned long cp_hash_string(void *key);

/**
 * case insensitive hash function for (char *) keys
 * @param key pointer to the cp_string
 * @return hash code of the key
 */
CPROPS_DLL 
unsigned long cp_hash_istring(void *key);


/**
 * copy function for cp_string copy tables
 */
CPROPS_DLL 
void *cp_hash_copy_string(void *element);

/**
 * comparator for (char *) keys
 * 
 * @param key1 pointer to the first cp_string
 * @param key2 pointer to the second cp_string
 * @retval 0 if key1 equals key2
 * @retval <>0 otherwise
 */
CPROPS_DLL 
int cp_hash_compare_string(void *key1, void *key2);


/**
 * comparator for (char *) keys
 * 
 * @param key1 pointer to the first cp_string
 * @param key2 pointer to the second cp_string
 * @retval 0 if key1 equals key2
 * @retval <>0 otherwise
 */
CPROPS_DLL 
int cp_hash_compare_istring(void *key1, void *key2);



/**
 * Internal object that implements a key, value pair plus linked list.
 * 
 * Entries which are stored under the same index in the hashtable are stored
 * in a linked list. The algorithm of the hashtable has to ensure that the lists
 * do not get too long.
 */
typedef CPROPS_DLL struct _cp_hashtable_entry 
{
    void *key;                   /**< key (original) needed for comparisons */
    void *value;                 /**< the item value being stored */
    unsigned long hashcode;      /**< save calculated hash-code of the key */
    struct _cp_hashtable_entry *next; /**< link to next entry */
} cp_hashtable_entry;

/**
 * data structure of generic synchronized cp_hashtable
 */
typedef CPROPS_DLL struct _cp_hashtable
{
    cp_hashtable_entry **table;     /**< array of pointers to entries */
    long table_size;                /**< size of the table */

    unsigned long items;            /**< number of items in the table */
    int mode;                       /**< collection mode @see collection.h */
    cp_hashfunction   hash_fn;      /**< pointer to hash function */
    cp_compare_fn     compare_fn;   /**< pointer to compare function */
    cp_copy_fn        copy_key;     /**< pointer to key copy function */
    cp_copy_fn        copy_value;   /**< pointer to value copy function */
	cp_destructor_fn  free_key;
	cp_destructor_fn  free_value;

    cp_lock           *lock;        /**< lock */
	cp_thread 		  txowner;    	/**< lock owner */
	int				  txtype;       /**< lock type */

	int min_size;					/**< table resize lower limit */
	int fill_factor_min;			/**< minimal fill factor in percent */
	int fill_factor_max;			/**< maximal fill factor in percent */

    cp_hashtable_entry **resize_table; /**< temp table for resizing */
    int resizing;                   /**< resize running flag */
    unsigned long resize_len;       /**< resize table length */
    cp_thread resize_thread;        /**< run resize in a separate thread  */
    cp_mutex *resize_lock;			/**< for synchronizing resize operation */
} cp_hashtable;


/**
 * creates a new cp_hashtable.
 *
 * by default there is no memory management for table content; insertion, 
 * removal and retrieval operations are synchronized; and the table will 
 * automatically resize when the fill factor goes over 70% or under 5%.
 * @param size_hint an estimate for the initial storage requirements. The table 
 *
 * handles the storage appropriately when items become too tight. 
 * @param hashfn a hash code function. This should ideally produce different
 * results for different keys.
 * @param compare_fn the comparator for your key type. 
 * 
 * @return a pointer to the newly created cp_hashtable.
 */
CPROPS_DLL 
cp_hashtable *
	cp_hashtable_create(unsigned long size_hint, 
						cp_hashfunction hashfn, 
						cp_compare_fn compare_fn);

/**
 * creates a new cp_hashtable with the specified mode.
 */
#define cp_hashtable_create_by_mode(mode, size_hint, cp_hashfn, compare_fn) \
        cp_hashtable_create_by_option((mode), (size_hint), (cp_hashfn), (compare_fn), NULL, NULL, NULL, NULL)

/**
 * creates a new cp_hashtable with COLLECTION_MODE_DEEP | COLLECTION_MODE_COPY.
 * @param size_hint an estimate for the initial storage requirements. The table 
 * handles the storage appropriately when items become too tight. 
 * @param hashfn a hash code function. This should ideally produce different
 * results for different keys.
 * @param compare_fn the comparator for your key type. 
 * 
 * @return a pointer to the newly created cp_hashtable.
 */
CPROPS_DLL 
cp_hashtable *
	cp_hashtable_create_copy_mode(unsigned long size_hint, 
								  cp_hashfunction hash_fn, 
								  cp_compare_fn compare_fn, 
             					  cp_copy_fn copy_key, 
								  cp_destructor_fn free_key,
								  cp_copy_fn copy_value,
								  cp_destructor_fn free_value);    

/**
 * create a new table, fully specifying all parameters.
 * @param size_hint   initial capacity
 * @param hash_fn     hash function
 * @param compare_fn  key comparison function
 * @param copy_key    function to return new copies of keys
 * @param copy_value  function to return new copies of values
 * @param mode        mode flags
 * 
 * @return new created cp_hashtable. Returns NULL case of error.
 */
CPROPS_DLL 
cp_hashtable *
	cp_hashtable_create_by_option(int mode, unsigned long size_hint, 
								  cp_hashfunction hash_fn, 
								  cp_compare_fn compare_fn, 
								  cp_copy_fn copy_key, 
								  cp_destructor_fn free_key,
								  cp_copy_fn copy_value,
								  cp_destructor_fn free_value);

/**
 * deletes a cp_hashtable according to the current mode settings
 * @param table        object to delete
 */
CPROPS_DLL 
void cp_hashtable_destroy(cp_hashtable *table);

/**
 * deletes a cp_hashtable. Pointers to the keys and values are not released. Use
 * table if the keys and values you entered in the table should not be released
 * by the cp_hashtable.
 * @param table        object to delete
 */
CPROPS_DLL 
void cp_hashtable_destroy_shallow(cp_hashtable *table);

/**
 * deletes a cp_hashtable. Keys and values entered in the cp_hashtable are released.
 * @param table        object to delete
 */
CPROPS_DLL 
void cp_hashtable_destroy_deep(cp_hashtable *table);


/** 
 * Deep destroy with custom destructors for keys and values. NULL function 
 * pointers are not invoked. 
 */
CPROPS_DLL 
void cp_hashtable_destroy_custom(cp_hashtable *table, cp_destructor_fn dk, cp_destructor_fn dv);

/** 
 * by default the get, put and remove functions as well as set and unset mode
 * perform their own locking. Other functions do not synchronize, since it is
 * assumed they would be called in a single cp_thread context - the initialization  * and deletion functions in particular. You can of course set 
 * COLLECTION_MODE_NOSYNC and perform your own synchronization.<p>
 * 
 * The current implementation uses a queued read/write lock where blocked
 * cp_threads are guaranteed to be woken by the order in which they attempted
 *
 * the following macros are defined for convenience:<p>
 * <ul>
 * <li> cp_hashtable_rdlock(table) - get a read lock on the table </li>
 * <li> cp_hashtable_wrlock(table) - get a write lock on the table </li>
 * </ul>
 * @param table        cp_hashtable to lock
 * @param type COLLECTION_LOCK_READ or COLLECTION_LOCK_WRITE
 */ 
CPROPS_DLL 
int cp_hashtable_lock(cp_hashtable *table, int type);

/** unlock the table */
CPROPS_DLL 
int cp_hashtable_unlock(cp_hashtable *table);

/** macro to get a read lock on the table
 */
#define cp_hashtable_rdlock(table) cp_hashtable_lock((table), COLLECTION_LOCK_READ)

/** macro to get a write lock on the table */
#define cp_hashtable_wrlock(table) cp_hashtable_lock((table), COLLECTION_LOCK_WRITE)

/**
 * returns the current operation mode. See cp_hashtable_set_mode for a list of
 * mode bits and their effects.
 */
CPROPS_DLL 
int cp_hashtable_get_mode(cp_hashtable *table);

/**
 * set the operation mode as a bit set of the following options:
 * <ul>
 *  <li> COLLECTION_MODE_DEEP - release memory when removing references from table    </li>
 *  <li> COLLECTION_MODE_MULTIPLE_PUT - allow multiple values for a key    </li>
 *  <li> COLLECTION_MODE_COPY - keep copies rather than references    </li>
 *  <li> COLLECTION_MODE_NOSYNC - the table will not perform its own synchronization.    </li>
 *  <li> COLLECTION_MODE_NORESIZE - the table will not resize automatically.    </li>
 * </ul>
 * 
 * The parameter bits are flipped on. If the current mode is 
 * COLLECTION_MODE_DEEP and you want to change it, call
 * cp_hashtable_unset_mode(table, COLLECTION_MODE_DEEP).
 */
CPROPS_DLL 
int cp_hashtable_set_mode(cp_hashtable *table, int mode);


/**
 * unset the mode bits defined by mode
 */
CPROPS_DLL 
int cp_hashtable_unset_mode(cp_hashtable *table, int mode);


/**
 * the internal table will not be resized to less than min_size
 */
CPROPS_DLL 
int cp_hashtable_set_min_size(cp_hashtable *table, int min_size);

/**
 * a resize is triggered when the table contains more items than
 * table_size * fill_factor / 100
 */
CPROPS_DLL 
int cp_hashtable_set_max_fill_factor(cp_hashtable *table, int fill_factor);

/**
 * a resize is triggered when the table contains less items than
 * table_size * fill_factor / 100
 */
CPROPS_DLL 
int cp_hashtable_set_min_fill_factor(cp_hashtable *table, int fill_factor);

/**
 * attempts to retrieve the value assigned to the key 'key'. To return
 * multiple values the table mode must be set to COLLECTION_MODE_MULTIPLE_VALUES, 
 * otherwise the only first value for the given key will be returned. 
 * @retval (void*)value to the value if found
 * @retval NULL otherwise 
 */
CPROPS_DLL 
void *cp_hashtable_get(cp_hashtable *table, void *key);

/** 
 * retrieve the value or values for key 'key'. the 'mode' parameter sets the
 * mode for the current operation.
 */
CPROPS_DLL 
void *cp_hashtable_get_by_option(cp_hashtable *table, void *key, int mode);

/**
 * Internal put method. 
 */
CPROPS_DLL 
void *cp_hashtable_put_by_option(cp_hashtable *table, void *key, void *value, int mode);

/**
 * the key 'key' will be assigned to the value 'value'. The new value will 
 * override an old value if one exists. The old value will not be deallocated.
 * If you would need the old value to be released call cp_hashtable_put_safe instead.
 */
CPROPS_DLL 
void *cp_hashtable_put(cp_hashtable *table, void *key, void *value);

/**
 * same as cp_hashtable_put(table, key, value) except that an old value is released if it
 * exists.
 */
CPROPS_DLL 
void *cp_hashtable_put_safe(cp_hashtable *table, void *key, void *value);

/**
 * same as cp_hashtable_put(table, key, value) except that it inserts a copy
 * of the key and the value object.
 */
CPROPS_DLL 
void *cp_hashtable_put_copy(cp_hashtable *table, void *key, void *value);

/**
 * Attempts to remove the mapping for key from the table.
 *
 * @param table   the object
 * @param key    Key to search for.
 * @retval value retrieved by the key (that was removed)
 * @retval NULL  if the table does not contain the requested key.
 */
CPROPS_DLL 
void *cp_hashtable_remove(cp_hashtable *table, void *key);

/** remove all entries with current mode */
CPROPS_DLL 
int cp_hashtable_remove_all(cp_hashtable *table);

/**
 * removes a mapping from the table, and deallocates the memory for the mapped
 * key and value.
 * 
 * @param table   the object
 * @param key    Key to search for.
 * @return 1 if the operation was successful, 0 otherwise
 */
CPROPS_DLL 
int cp_hashtable_remove_deep(cp_hashtable *table, void *key);

/**
 * Check if there is an entry with matching key.
 *
 * @param table   the object
 * @param key    Key to search for.
 * @return 1 if table contains key, 0 otherwise
 */
CPROPS_DLL 
int cp_hashtable_contains(cp_hashtable *table, void *key);

/**
 * get an array containing all keys mapped in table table.
 * @note It is the responsibility of the caller to free the returned array. 
 * @note The keys themselves must not be changed or deleted (read-only).
 */
CPROPS_DLL 
void **cp_hashtable_get_keys(cp_hashtable *table);

/**
 * get an array containing all values in the table.
 * @note It is the responsibility of the caller to free the returned array. 
 * @note The values themselves must not be changed or deleted (read-only).
 */
CPROPS_DLL 
void **cp_hashtable_get_values(cp_hashtable *table);

/**
 * Get the number of entries in the collection.
 * @return the number of key mappings currently in the table.
 */
CPROPS_DLL 
unsigned long cp_hashtable_count(cp_hashtable *table);

/**
 * Check if the collection is empty.
 * @retval true/1 if the collection is empty
 * @retval false/0 if the collection has entries
 */
#define cp_hashtable_is_empty(table) (cp_hashtable_count(table) == 0)

/**
 * @return a prime greater than <code>size_request</code>
 */
CPROPS_DLL 
unsigned long cp_hashtable_choose_size(unsigned long size_request);

__END_DECLS
/** @} */
#endif


typedef struct _shared_mempool_entry
{
	size_t item_size;
	cp_mempool *pool;
	struct _shared_mempool_entry *next;
} shared_mempool_entry;

/* cp_shared_mempool is a generalized memory pool. It allows requesting variable
 * block sizes. For best results, register the required block sizes in advance.
 * requests for unregistered block sizes will return memory from a default
 * internal list, which rounds up the block size to the next bit. For example
 * allocating an unregisterd block of size 12 will return a 16 byte block. 
 * In partcular large allocations could return a lot of extra memory.
 */
typedef CPROPS_DLL struct _cp_shared_mempool
{
	unsigned int reg_tbl_size;
	unsigned int reg_tbl_count;

	shared_mempool_entry **reg_tbl;
	struct _cp_rbtree *chunk_tracker;

	int mode;
	int gm_mode;

	/* lock for mempool lists */
	cp_mutex *lock;

	int multiple; /* number of pages to allocate in sub pools */
} cp_shared_mempool;

/* ``smaller'': arbitrary size allocations are rounded up to the next bit. The
 * pool is ``smaller'' in that up to about WORD_SIZE internal memory pools are
 * allocated to serve unregistered allocation size requests.
 */
#define CP_SHARED_MEMPOOL_TYPE_1 1
/* ``faster'': arbitrary size allocations are rounded up to the word size. The 
 * pool is ``faster'' in that typically the allocation overhead is smaller, and
 * the number of operations required to determine which pool to use internally
 * is smaller. On the other hand, since a large number of memory pool could be
 * allocated internally, this may not be usable in some circumstances. 
 */
#define CP_SHARED_MEMPOOL_TYPE_2 2

/* cp_shared_mempool_create */
CPROPS_DLL
cp_shared_mempool *cp_shared_mempool_create();

/* cp_shared_mempool_create_by_option */
CPROPS_DLL
cp_shared_mempool *
	cp_shared_mempool_create_by_option(int mode, 
									   int arbitrary_allocation_strategy,
									   int size_hint, 
									   int page_count);

/* cp_shared_mempool destroy */
CPROPS_DLL
void cp_shared_mempool_destroy(cp_shared_mempool *pool);

/* cp_shared_mempool_register */
CPROPS_DLL
cp_mempool *cp_shared_mempool_register(cp_shared_mempool *pool, size_t size);

/* cp_shared_mempool_alloc */
CPROPS_DLL
void *cp_shared_mempool_alloc(cp_shared_mempool *pool, size_t size);

/* cp_shared_mempool_calloc */
CPROPS_DLL
void *cp_shared_mempool_calloc(cp_shared_mempool *pool, size_t size);

/* cp_shared_mempool_free */
CPROPS_DLL
void cp_shared_mempool_free(cp_shared_mempool *pool, void *p);

__END_DECLS

#endif /* _CP_MEMPOOL_H */




#ifndef _CP_SPLAY_H
#define _CP_SPLAY_H

__BEGIN_DECLS

CPROPS_DLL struct _cp_splaytree;

typedef CPROPS_DLL struct _cp_splaynode
{
	void *key;
	void *value;
	
	struct _cp_splaynode *left;
	struct _cp_splaynode *right;
} cp_splaynode;

/* (internal) allocate a new node */
CPROPS_DLL
cp_splaynode *cp_splaynode_create(void *key, void *value, cp_mempool *pool);
/* (internal) deallocate a node */
CPROPS_DLL
void cp_splaytree_destroy_node(struct _cp_splaytree *tree, cp_splaynode *node);
/* (internal) deallocate a node and its subnodes */
CPROPS_DLL
void cp_splaytree_destroy_node_deep(struct _cp_splaytree *owner, cp_splaynode *node);


/* tree wrapper object */
typedef CPROPS_DLL struct _cp_splaytree
{
        //niloo
        int opCount;

	cp_splaynode *root;          /* root node */
	
	int items;                   /* item count */

	int mode;					 /* mode flags */
	cp_compare_fn cmp;           /* key comparison function */
	cp_copy_fn key_copy;         /* key copy function */
	cp_destructor_fn key_dtr;    /* key destructor */
	cp_copy_fn value_copy;       /* value copy function */
	cp_destructor_fn value_dtr;  /* value destructor */
	cp_lock *lock;
	cp_thread txowner;           /* set if a transaction is in progress */
	int txtype;                  /* lock type */

	cp_mempool *mempool; 		 /* memory pool */
} cp_splaytree;

/* 
 * default create function - equivalent to create_by_option with mode 
 * COLLECTION_MODE_NOSYNC
 */
CPROPS_DLL
cp_splaytree *cp_splaytree_create(cp_compare_fn cmp);

/*
 * complete parameter create function. Note that setting COLLECTION_MODE_COPY
 * without specifying a copy function for either keys or values will result in
 * keys or values respectively being inserted by value, with no copying 
 * performed. Similarly, setting COLLECTION_MODE_DEEP without specifying a 
 * destructor function for keys or values will result in no destructor call
 * for keys or values respectively. This allows using the copy/deep mechanisms
 * for keys only, values only or both.
 */
CPROPS_DLL
cp_splaytree *
	cp_splaytree_create_by_option(int mode, cp_compare_fn cmp, 
								cp_copy_fn key_copy, cp_destructor_fn key_dtr,
								cp_copy_fn val_copy, cp_destructor_fn val_dtr);

/* 
 * recursively destroy the tree structure 
 */
CPROPS_DLL
void cp_splaytree_destroy(cp_splaytree *tree);

/*
 * recursively destroy the tree structure with the given destructor functions
 */
CPROPS_DLL
void cp_splaytree_destroy_custom(cp_splaytree *tree, 
							   cp_destructor_fn key_dtr,
							   cp_destructor_fn val_dtr);

/* insertion function */
CPROPS_DLL
void *cp_splaytree_insert(cp_splaytree *tree, void *key, void *value);
/* retrieve the value mapped to the given key */
CPROPS_DLL
void *cp_splaytree_get(cp_splaytree *tree, void *key);
/* return non-zero if a mapping for 'key' could be found */
CPROPS_DLL
int cp_splaytree_contains(cp_splaytree *tree, void *key);
/* delete a mapping */
CPROPS_DLL
void *cp_splaytree_delete(cp_splaytree *tree, void *key);

/* 
 * perform a pre-order iteration over the tree, calling 'callback' on each 
 * node
 */
CPROPS_DLL
int cp_splaytree_callback_preorder(cp_splaytree *tree, 
								 cp_callback_fn callback, 
								 void *prm);
/* 
 * perform an in-order iteration over the tree, calling 'callback' on each 
 * node
 */
CPROPS_DLL
int cp_splaytree_callback(cp_splaytree *tree, cp_callback_fn callback, void *prm);
/* 
 * perform a post-order iteration over the tree, calling 'callback' on each 
 * node
 */
CPROPS_DLL
int cp_splaytree_callback_postorder(cp_splaytree *tree, 
								  cp_callback_fn callback, 
								  void *prm);

/* return the number of mappings in the tree */
CPROPS_DLL
int cp_splaytree_count(cp_splaytree *tree);

/* 
 * lock tree for reading or writing as specified by type parameter. 
 */
CPROPS_DLL
int cp_splaytree_lock(cp_splaytree *tree, int type);
/* read lock */
#define cp_splaytree_rdlock(tree) \
	(cp_splaytree_lock((tree), COLLECTION_LOCK_READ))
/* write lock */
#define cp_splaytree_wrlock(tree) \
	(cp_splaytree_lock((tree), COLLECTION_LOCK_WRITE))
/* unlock */
CPROPS_DLL
int cp_splaytree_unlock(cp_splaytree *tree);


/* return the table mode indicator */
CPROPS_DLL
int cp_splaytree_get_mode(cp_splaytree *tree);
/* set mode bits on the tree mode indicator */
CPROPS_DLL
int cp_splaytree_set_mode(cp_splaytree *tree, int mode);
/* unset mode bits on the tree mode indicator. if unsetting 
 * COLLECTION_MODE_NOSYNC and the tree was not previously synchronized, the 
 * internal synchronization structure is initalized.
 */
CPROPS_DLL
int cp_splaytree_unset_mode(cp_splaytree *tree, int mode);

/* print tree to stdout */
CPROPS_DLL
void cp_splaytree_dump(cp_splaytree *tree);

/* set tree to use given mempool or allocate a new one if pool is NULL */
CPROPS_DLL
int cp_splaytree_use_mempool(cp_splaytree *tree, cp_mempool *pool);

/* set tree to use a shared memory pool */
CPROPS_DLL
int cp_splaytree_share_mempool(cp_splaytree *tree, cp_shared_mempool *pool);


__END_DECLS

/** @} */

#endif


#ifdef CP_HAS_STRINGS_H
#include <strings.h>      /* for strcasecmp */
#else	/* 
 */
#ifndef _CP_UTIL_H
#define _CP_UTIL_H


#ifdef CP_HAS_SYS_TIME_H
#include <sys/time.h>
#else
#include <time.h>
#endif
__BEGIN_DECLS

/**
 * assorted goodies
 */

#ifndef CP_HAS_STRLCAT
#define strlcat strncat
#endif /* CP_HAS_STRLCAT */

#ifndef CP_HAS_STRLCPY
#define strlcpy strncpy
#endif /* CP_HAS_STRLCPY */

#ifndef CP_HAS_SNPRINTF
#ifdef _WINDOWS
#define snprintf _snprintf
#define CP_HAS_SNPRINTF
#endif /* _WINDOWS */
#endif /* CP_HAS_SNPRINTF */

#ifndef CP_HAS_STRDUP
/**
 * Copies cp_string into newly allocated memory.
 *
 * @retval pointer to copied cp_string
 * @retval NULL if src was NULL
 */
CPROPS_DLL
char *strdup(char *src);
#endif /* missing strdup */

#ifndef CP_HAS_STRNDUP
/**
 * Copies up to maxlen characters of src cp_string into newly allocated memory.
 *
 * @retval pointer to copied cp_string
 * @retval NULL if src was NULL
 */
CPROPS_DLL
char *strndup(char *src, int maxlen);
#endif /* missing strndup */

#ifndef CP_HAS_STRCASECMP
#ifdef _WINDOWS
#define strcasecmp _stricmp
#else
int strcasecmp(const char *a, const char *b);
#endif
#endif /* CP_HAS_STRNCASECMP */

#ifndef CP_HAS_STRNCASECMP
#ifdef _WINDOWS
#define strncasecmp _strnicmp
#else
int strncasecmp(const char *a, const char *b, size_t len);
#endif
#endif /* CP_HAS_STRNCASECMP */

#ifndef CP_HAS_GETTIMEOFDAY
#ifdef _WINDOWS
CPROPS_DLL
int gettimeofday(struct timeval *res, struct timezone *tz);
#endif
#endif /* missing gettimeofday */

/* cp_sleep - a platform independent function to sleep n seconds */
CPROPS_DLL
int cp_sleep(int sec);

/**
 * @todo check for buffer overflow
 */
CPROPS_DLL
char *str_trim_cpy(char *dst, char *src);


/**
 * scans a cp_string for the first occurence of ch within the first len bytes at
 * most. searching for the null character will return a pointer to the 
 * terminating null. 
 */
CPROPS_DLL
char *strnchr(char *str, char ch, int len);


/**
 * Map character 't', 'T' to true.
 */
CPROPS_DLL
int parse_boolean(char *value);

/**
 * Map integer value to characters 't', 'f'.
 */
#define format_boolean(val) ((val) ? "t" : "f")


/**
 * Get the current time as long value (UNIX).
 */
CPROPS_DLL
long get_timestamp();

/**
 * Return the cp_string or if NULL an empty cp_string.
 */
CPROPS_DLL
char *dbfmt(char *str);


/**
 * Retrieves the ip-adress of the system where it is running on.
 */
CPROPS_DLL
unsigned long get_current_ip();

/**
 * Retrieve the ip-address of the system with the 'hostname'.
 */
CPROPS_DLL
unsigned long get_host_ip(char *hostname);

/**
 * Formats an ip-address (IPv4) with dot notation.
 */
CPROPS_DLL
char *ip_to_string(unsigned long ip, char *buf, size_t len);

/** 
 * converts hex to url encoded binary (eg ABCD => %AB%CD) and returns a newly
 * allocated cp_string
 */
CPROPS_DLL
char *hex_url_encode(char *hex);

/** 
 * return a static string coresponding to the posix regcomp error code given
 * as a parameter. the error descriptions come from the gnu man page. 
 */
CPROPS_DLL
char *regex_compilation_error(int rc);

/**
 * return a static string describing the stat return code given as a parameter.
 * the resulting error string contains 2 '%s' sequences - the first one could 
 * be used for the program name, function description etc, the second one 
 * for the stat()ed path.
 */
CPROPS_DLL
char *stat_error_fmt(int err);

/**
 * check if the directory specified by path exists
 */
CPROPS_DLL
int checkdir(char *path);

/**
 * generates a 16 character id based on the current time. The generated id 
 * followed by a terminating null character are written into buf.
 */
CPROPS_DLL
void gen_id_str(char *buf);

/**
 * generates a 16 character id based on the given time. The generated id 
 * followed by a terminating null character are written into buf.
 */
CPROPS_DLL
void gen_tm_id_str(char *buf, struct timeval *tm);

/**
 * get a timestamp for the last modification to the file designated by path
 */
CPROPS_DLL
time_t last_change_time(char *path);

/** duplicate an integer */
CPROPS_DLL
int *intdup(int *src);

/** duplicate a long integer */
CPROPS_DLL
long *longdup(long *src);

/** duplicate a floating point value */
CPROPS_DLL
float *floatdup(float *src);

/** duplicate a double precision floating point value */
CPROPS_DLL
double *doubledup(double *src);

/** duplicate an array */
CPROPS_DLL
void *memdup(void *src, int len);

/** convert a hex string to an integer value */
CPROPS_DLL
int xtoi(char *p);

/** convert a hex string to a long value */
CPROPS_DLL
int xtol(char *p);

/** return flipped string in a newly allocated buffer */
CPROPS_DLL
char *reverse_string(char *str);

/** flip a string in place */
CPROPS_DLL
char *reverse_string_in_place(char *str);

/** remove all occurrences of letters from str */
CPROPS_DLL
char *filter_string(char *str, char *letters);

/** convert string to lower case characters */
CPROPS_DLL
char *to_lowercase(char *str);

/** convert string to upper case characters */
CPROPS_DLL
char *to_uppercase(char *str);

#ifndef CP_HAS_GETOPT
extern CPROPS_DLL char *optarg;

CPROPS_DLL
int getopt(int argc, char *argv[], char *fmt);
#endif /* no getopt */

#ifndef CP_HAS_INET_NTOP
#ifdef _WINDOWS

CPROPS_DLL
char *inet_ntop(int af, const void *src, char *dst, size_t cnt);
#endif /* _WINDOWS */
#endif /* CP_HAS_INET_NTOP */

#ifndef CP_HAS_DLFCN_H
#ifdef _WINDOWS
CPROPS_DLL
void *dlopen(char *file, int mode);

CPROPS_DLL
int dlclose(void *handle);

CPROPS_DLL
void *dlsym(void *handle, char *name);

CPROPS_DLL
char *dlerror();

/* none if this is actually supported by the win32 api, just define the symbols
 * so the build doesn't break. 
 */
#define RTLD_LAZY   0
#define RTLD_NOW    0
#define RTLD_LOCAL  0
#define RTLD_GLOBAL 0

#endif /* WINDOWS */
#endif /* CP_HAS_DLFCN_H */

#ifndef CP_HAS_GETCWD
#ifdef _WINDOWS
#include "direct.h"
#define getcwd _getcwd
#endif /* _WINDOWS */
#endif /* CP_HAS_GETCWD */

#ifdef _WINDOWS
/* convenience function to create a process under windows */
CPROPS_DLL
int create_proc(char *path, 
				void *child_stdin, 
				void *child_stdout, 
				void *child_stderr,
				char **envp);
#endif /* _WINDOWS */

CPROPS_DLL
void replace_char(char *buf, char from, char to);

CPROPS_DLL
char *ssl_err_inf(int err);

/* ----------------------------------------------------------------- */

__END_DECLS

/** @} */
#endif


#endif	/* CP_HAS_STRINGS_H */





#include <stdlib.h>		       /* for calloc() and malloc() */
#include <string.h>		       /* for memset() */
#include <errno.h>		       /* for errno and EINVAL */

#ifdef CP_HAS_GETPAGESIZE
#include <unistd.h>		       /* for getpagesize() */
#else
int getpagesize() { return 0x2000; }
#endif /* CP_HAS_GETPAGESIZE */

#ifndef WORD_SIZE
#define WORD_SIZE (sizeof(void *))
#endif /* WORD_SIZE */

#if defined(CP_HAS_PTHREAD_MUTEX_RECURSIVE) || defined(CP_HAS_PTHREAD_MUTEX_RECURSIVE_NP)
#define CP_MEMPOOL_TXLOCK(pool, err_ret) { \
    if (!((pool)->mode & COLLECTION_MODE_NOSYNC)) \
	if (cp_mutex_lock((pool)->lock)) \
	    return err_ret; \
}
#define CP_MEMPOOL_TXUNLOCK(pool, err_ret) { \
    if (!((pool)->mode & COLLECTION_MODE_NOSYNC)) \
	if (cp_mutex_unlock((pool)->lock)) \
	    return err_ret; \
}
#else
#define CP_MEMPOOL_TXLOCK(pool, err_ret) { \
    if (!((pool)->mode & COLLECTION_MODE_NOSYNC)) \
    { \
        cp_thread self = cp_thread_self(); \
        if (!cp_thread_equal(self, (pool)->txowner) && \
	        cp_mutex_lock((pool)->lock)) \
	        return err_ret; \
        (pool)->txowner = self; \
    } \
}
#define CP_MEMPOOL_TXUNLOCK(pool, err_ret) { \
    if (!((pool)->mode & COLLECTION_MODE_NOSYNC)) \
    { \
        cp_thread self = cp_thread_self(); \
        if (!cp_thread_equal(self, (pool)->txowner) && \
	        cp_mutex_unlock((pool)->lock)) \
	        return err_ret; \
        (pool)->txowner = 0; \
    } \
}
#endif /* CP_HAS_PTHREAD_MUTEX_RECURSIVE */
static size_t pagesize = 0;

cp_mempool *cp_mempool_create_by_option(const int mode, 
                                    	size_t item_size, 
                                    	size_t alloc_size)
{
	cp_mempool *pool = (cp_mempool *) calloc(1, sizeof(cp_mempool));
	if (pool == NULL) return NULL;

	pool->mode = mode;

	if (!(mode & COLLECTION_MODE_NOSYNC))
	{
#if defined(PTHREAD_MUTEX_RECURSIVE) || defined(PTHREAD_MUTEX_RECURSIVE_NP)
		pthread_mutexattr_t attr;
#endif /* PTHREAD_MUTEX_RECURSIVE */
		pool->lock = (cp_mutex *) malloc(sizeof(cp_mutex));
		if (pool->lock == NULL)
		{
			cp_mempool_destroy(pool);
			return NULL;
		}
#ifdef PTHREAD_MUTEX_RECURSIVE
		pthread_mutexattr_init(&attr);
		pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
		cp_mutex_init(pool->lock, &attr);
#else
		cp_mutex_init(pool->lock, NULL);
#endif /* PTHREAD_MUTEX_RECURSIVE */
	}

	if (pagesize == 0) pagesize = getpagesize();

	/* first, we ensure that item_size is a multiple of WORD_SIZE,
	 * and also that it is at least sizeof(void*). The first
	 * condition may imply the second on *most* platforms, but it
	 * costs us very little to make sure. */
	if (item_size < sizeof(void*)) item_size = sizeof(void*);
	if (item_size % WORD_SIZE)
		item_size += (WORD_SIZE) - (item_size % WORD_SIZE);
	pool->item_size = item_size;
	/* next, we pump up the alloc_size until it is at least big enough
	 * to hold ten chunks plus a void pointer, or ten pages, whichever
	 * is bigger. The reason for doing it this way rather than simply
	 * adding sizeof(void*) to alloc_size is that we want alloc_size to
	 * be a multiple of pagesize (this makes it faster!). */
	if (alloc_size < item_size * 10 + sizeof(void *))
		alloc_size = item_size * 10 + sizeof(void *);
	if (alloc_size < pagesize * 10) alloc_size = pagesize * 10;
	if (alloc_size % pagesize)
		alloc_size += pagesize - (alloc_size % pagesize);
	pool->alloc_size = alloc_size;

	pool->items_per_alloc = (alloc_size - sizeof(void *)) / item_size;

	pool->reuse_pool = NULL;
	pool->alloc_pool = (char *) malloc(alloc_size);
	if (pool->alloc_pool == NULL)
	{
		free(pool);
		return NULL;
	}
	*(void **) pool->alloc_pool = NULL;

	return pool;
}


cp_mempool *cp_mempool_create(const size_t item_size)
{
	return cp_mempool_create_by_option(COLLECTION_MODE_NOSYNC, item_size, 0);
}


void *cp_mempool_alloc(cp_mempool * const pool)
{
	void *p;

	CP_MEMPOOL_TXLOCK(pool, NULL);

	if (pool->reuse_pool)
	{
		p = pool->reuse_pool;
		pool->reuse_pool = *(void **)p;
	}
	else
	{
		if (pool->alloc_pool_pos == pool->items_per_alloc)
		{
			p = malloc(pool->alloc_size);
			if (p == NULL) return NULL;
			*(void **) p = pool->alloc_pool;
			pool->alloc_pool = p;
			pool->alloc_pool_pos = 0;
			/* if this pool is owned by a shared_mempool, report allocations */
			if (pool->alloc_callback) 
				(*pool->alloc_callback)(pool->callback_prm, pool, p);
		}
		p = pool->alloc_pool + sizeof(void *) + 
			pool->item_size * pool->alloc_pool_pos++;
	}

	CP_MEMPOOL_TXUNLOCK(pool, NULL);

	return p;
}

void *cp_mempool_calloc(cp_mempool * const pool)
{
	void *p = cp_mempool_alloc(pool);
	if (p)
		memset(p, 0, pool->item_size);
	return p;
}

int cp_mempool_free(cp_mempool * const pool, void *data)
{
	CP_MEMPOOL_TXLOCK(pool, -1);
	*(void **) data = pool->reuse_pool;
	pool->reuse_pool = data;
	CP_MEMPOOL_TXUNLOCK(pool, -1);
	return 0;
}

/* increment refcount */
int cp_mempool_inc_refcount(cp_mempool *pool)
{
	CP_MEMPOOL_TXLOCK(pool, -1);
	pool->refcount++;
	CP_MEMPOOL_TXUNLOCK(pool, -1);
	return 0;
}

void cp_mempool_destroy(cp_mempool *pool)
{
	if (pool)
	{
		if (pool->refcount-- <= 0)
		{
			void *p;

			while ((p = pool->alloc_pool))
			{
				pool->alloc_pool = *(void **) pool->alloc_pool;
				free(p);
			}
		}
	}
}

void cp_mempool_set_callback(cp_mempool *pool, void *prm, cp_mempool_callback_fn cb)

{
	pool->alloc_callback = cb;
	pool->callback_prm = prm;
}


/****************************************************************************
 *                                                                          *
 *                         cp_shared_mempool functions                      *
 *                                                                          *
 ****************************************************************************/

typedef struct _chunk_track
{
	void *mem;
	size_t size;
} chunk_track;

chunk_track *get_chunk_track(void *mem, size_t size)
{
	chunk_track *t = (chunk_track *) malloc(sizeof(chunk_track));
	if (t)
	{
		t->mem = mem;
		t->size = size;
	}
	return t;
}

int compare_chunk_track(void *c1, void *c2)
{
	chunk_track *t1 = c1;
	chunk_track *t2 = c2;
	return (t2->size == 0 && 
            t2->mem >= t1->mem && 
			((char *) t2->mem - (char *) t1->mem) < t1->size) ||
		   (t1->size == 0 && 
            t1->mem >= t2->mem && 
			((char *) t1->mem - (char *) t2->mem) < t2->size) ? 0 : 
		((char *) t1->mem - (char *) t2->mem);
}

cp_mempool *shared_mempool_entry_get(cp_shared_mempool *pool, size_t size)
{
	shared_mempool_entry *entry = pool->reg_tbl[size % pool->reg_tbl_size];

	while (entry && entry->item_size != size) entry = entry->next;
	if (entry) return entry->pool;

	return NULL;
}

cp_mempool *shared_mempool_entry_put(cp_shared_mempool *pool, 
									 size_t size, cp_mempool *sub)
{
	shared_mempool_entry **entry = &pool->reg_tbl[size % pool->reg_tbl_size];

	while ((*entry) && (*entry)->item_size != size) 
		entry = &(*entry)->next;

	if (*entry == NULL)
	{
		*entry = calloc(1, sizeof(shared_mempool_entry));
		(*entry)->item_size = size;
	}

	(*entry)->pool = sub;
	return sub;
}

void shared_mempool_entry_destroy(cp_shared_mempool *pool)
{
	int i;

	for (i = 0; i < pool->reg_tbl_size; i++)
	{
		shared_mempool_entry *curr, *tmp;
		curr = pool->reg_tbl[i];
		while (curr)
		{
			tmp = curr;
			curr = curr->next;
			cp_mempool_destroy(tmp->pool);
			free(tmp);
		}
	}

	free(pool->reg_tbl);
}

/* cp_shared_mempool_create */
cp_shared_mempool *cp_shared_mempool_create()
{
	return 
		cp_shared_mempool_create_by_option(0, CP_SHARED_MEMPOOL_TYPE_2, 0, 0);
}

/* cp_shared_mempool_create_by_option */
CPROPS_DLL
cp_shared_mempool *
	cp_shared_mempool_create_by_option(int mode, 
									   int arbitrary_allocation_strategy,
									   int size_hint, 
									   int page_count)
{
	cp_shared_mempool *pool = 
		(cp_shared_mempool *) calloc(1, sizeof(cp_shared_mempool));
	if (pool == NULL) return NULL;

	if (size_hint)
		size_hint = size_hint * 2 + 1; /* choose an odd number */
	else 
		size_hint = 211; /* 211 is a prime */

	pool->reg_tbl = calloc(size_hint, sizeof(shared_mempool_entry *));
	if (pool->reg_tbl == NULL) goto CREATE_ERROR;
	pool->reg_tbl_size = size_hint;

	pool->mode = mode;

	if ((mode & COLLECTION_MODE_NOSYNC))
	{
		pool->lock = (cp_mutex *) malloc(sizeof(cp_mutex));
		if (pool->lock == NULL) goto CREATE_ERROR;
		if ((cp_mutex_init(pool->lock, NULL))) goto CREATE_ERROR;
	}

	if (arbitrary_allocation_strategy == 0)
		pool->gm_mode = CP_SHARED_MEMPOOL_TYPE_1;
	else
		pool->gm_mode = arbitrary_allocation_strategy;

	pool->multiple = page_count;

	pool->chunk_tracker = 
		cp_rbtree_create_by_option(mode | COLLECTION_MODE_DEEP, 
								   compare_chunk_track, NULL, free, NULL, NULL);
	if (pool->chunk_tracker == NULL) goto CREATE_ERROR;

	return pool;

CREATE_ERROR:
	if (pool->lock)
	{
		free(pool->lock);
		pool->lock = NULL;
	}
	cp_shared_mempool_destroy(pool);
	return NULL;
}

/* cp_shared_mempool destroy */
CPROPS_DLL
void cp_shared_mempool_destroy(cp_shared_mempool *pool)
{
	if (pool)
	{
		cp_rbtree_destroy(pool->chunk_tracker);
		shared_mempool_entry_destroy(pool);
		if (pool->lock)
		{
			cp_mutex_destroy(pool->lock);
			free(pool->lock);
		}
		free(pool);
	}
}

void cp_shared_mempool_track_alloc(cp_shared_mempool *pool, 
								   cp_mempool *sub, void *mem)
{
	cp_rbtree_insert(pool->chunk_tracker, 
					 get_chunk_track(mem, sub->alloc_size), sub);
}

/* cp_shared_mempool_register */
cp_mempool *cp_shared_mempool_register(cp_shared_mempool *pool, size_t size)
{
	cp_mempool *sub;
	if (size % WORD_SIZE) size += WORD_SIZE - (size % WORD_SIZE);
	sub = shared_mempool_entry_get(pool, size);
	if (sub)
		cp_mempool_inc_refcount(sub);
	else
	{
		sub = cp_mempool_create_by_option(pool->mode, size, pool->multiple);
		cp_mempool_set_callback(sub, pool, 
			(cp_mempool_callback_fn) cp_shared_mempool_track_alloc);
		shared_mempool_entry_put(pool, size, sub);
	}

	return sub;
}

#if 0
/* unregister a mempool */
void cp_shared_mempool_unregister(cp_shared_mempool *pool, size_t size)
{
	cp_mempool *sub;
	if (size % WORD_SIZE) size += WORD_SIZE - (size % WORD_SIZE);
	sub = shared_mempool_entry_get(pool, size);
	if (sub)
		cp_mempool_destroy(sub);
}
#endif

/* cp_shared_mempool_alloc */
CPROPS_DLL
void *cp_shared_mempool_alloc(cp_shared_mempool *pool, size_t size)
{
	size_t actual;
	cp_mempool *mempool = NULL;

	if (size % WORD_SIZE) size += WORD_SIZE - (size % WORD_SIZE);
	
	if ((mempool = shared_mempool_entry_get(pool, size)))
		return cp_mempool_alloc(mempool);

	if ((pool->gm_mode & CP_SHARED_MEMPOOL_TYPE_2))
		actual = size;
	else
	{
		actual = WORD_SIZE;
		while (actual < size) actual <<= 1;
	}
	if ((mempool = cp_shared_mempool_register(pool, actual)))
		return cp_mempool_alloc(mempool);

	return NULL;
}

/* cp_shared_mempool_calloc */
CPROPS_DLL
void *cp_shared_mempool_calloc(cp_shared_mempool *pool, size_t size)
{
	size_t actual;
	cp_mempool *mempool = NULL;

	if (size % WORD_SIZE) size += WORD_SIZE - (size % WORD_SIZE);
	
	if ((mempool = shared_mempool_entry_get(pool, size)))
		return cp_mempool_calloc(mempool);

	if ((pool->gm_mode & CP_SHARED_MEMPOOL_TYPE_2))
		actual = size;
	else
	{
		actual = WORD_SIZE;
		while (actual < size) actual <<= 1;
	}
	if ((mempool = cp_shared_mempool_register(pool, actual)))
		return cp_mempool_calloc(mempool);

	return NULL;
}


/* cp_shared_mempool_free */
CPROPS_DLL
void cp_shared_mempool_free(cp_shared_mempool *pool, void *p)
{
	cp_mempool *mempool;
	chunk_track ct;
	memset(&ct, 0, sizeof(chunk_track));
	ct.mem = p;

	if ((mempool = cp_rbtree_get(pool->chunk_tracker, &ct)))
		cp_mempool_free(mempool, p);
}







/***************************  memory  ************************************/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>


cp_rbnode *cp_rbnode_create(void *key, void *value, cp_mempool *pool)
{
	cp_rbnode *node;
	
	if (pool) 
		node = (cp_rbnode *) cp_mempool_calloc(pool);
	else
		node = (cp_rbnode *) calloc(1, sizeof(cp_rbnode));

	if (node == NULL) return NULL;

	node->key = key;
	node->value = value;

	return node;
}
	
/* implement COLLECTION_MODE_COPY if set */
static cp_rbnode *create_rbnode(cp_rbtree *tree, void *key, void *value)
{
	if (tree->mode & COLLECTION_MODE_COPY)
	{
		void *k, *v;
		k = tree->key_copy ? (*tree->key_copy)(key) : key;
		if (k)
		{
			v = tree->value_copy ? (*tree->value_copy)(value) : value;
			if (v)
			{
				if (tree->mode & COLLECTION_MODE_MULTIPLE_VALUES)
				{
					cp_vector *m = cp_vector_create(1);
					if (m == NULL) return NULL;
					cp_vector_add_element(m, v);
					v = m;
				}
				return cp_rbnode_create(k, v, tree->mempool);
			}
		}
	}
	else if (tree->mode & COLLECTION_MODE_MULTIPLE_VALUES)
	{
		cp_vector *m = cp_vector_create(1);
		if (m == NULL) return NULL;
		cp_vector_add_element(m, value);
		return cp_rbnode_create(key, m, tree->mempool);
	}
	else 
		return cp_rbnode_create(key, value, tree->mempool);

	return NULL;
}

void cp_rbtree_destroy_node_deep(cp_rbtree *owner, cp_rbnode *node)
{
    while (node)
    {
        if (node->right)
        {
            node = node->right;
            node->up->right = NULL;
        }
        else if (node->left)
        {
            node = node->left;
            node->up->left = NULL;
        }
        else
        {
            cp_rbnode *tmp = node;
            node = node->up;
            cp_rbtree_destroy_node(owner, tmp);
        }
    }
}

void cp_rbtree_destroy_node(cp_rbtree *tree, cp_rbnode *node)
{
	if (node)
	{
		if ((tree->mode & COLLECTION_MODE_DEEP))
		{
			if (tree->key_dtr) (*tree->key_dtr)(node->key);
			if ((tree->mode & COLLECTION_MODE_MULTIPLE_VALUES) && node->value)
				cp_vector_destroy_custom(node->value, tree->value_dtr);
			else if (tree->value_dtr) 
				(*tree->value_dtr)(node->value);
		}
		else if ((tree->mode & COLLECTION_MODE_MULTIPLE_VALUES) && node->value)
			cp_vector_destroy(node->value);
		if (tree->mempool)
			cp_mempool_free(tree->mempool, node);
		else
			free(node);
	}
}


cp_rbtree *cp_rbtree_create(cp_compare_fn cmp)
{
	cp_rbtree *tree = calloc(1, sizeof(cp_rbtree));
	if (tree == NULL) return NULL;

	tree->mode = COLLECTION_MODE_NOSYNC;
	tree->cmp = cmp;

	return tree;
}

/*
 * complete parameter create function
 */
cp_rbtree *
	cp_rbtree_create_by_option(int mode, cp_compare_fn cmp, 
							   cp_copy_fn key_copy, cp_destructor_fn key_dtr,
							   cp_copy_fn val_copy, cp_destructor_fn val_dtr)
{
	cp_rbtree *tree = cp_rbtree_create(cmp);
	if (tree == NULL) return NULL;
	
	tree->mode = mode;
	tree->key_copy = key_copy;
	tree->key_dtr = key_dtr;
	tree->value_copy = val_copy;
	tree->value_dtr = val_dtr;

	if (!(mode & COLLECTION_MODE_NOSYNC))
	{
		tree->lock = malloc(sizeof(cp_lock));
		if (tree->lock == NULL) 
		{
			cp_rbtree_destroy(tree);
			return NULL;
		}
		if (cp_lock_init(tree->lock, NULL) != 0)
		{
			cp_rbtree_destroy(tree);
			return NULL;
		}
	}

	return tree;
}


void cp_rbtree_destroy(cp_rbtree *tree)
{
	if (tree)
	{
		cp_rbtree_destroy_node_deep(tree, tree->root);
		if (tree->lock)
		{
			cp_lock_destroy(tree->lock);
			free(tree->lock);
		}
		free(tree);
	}
}

void cp_rbtree_destroy_custom(cp_rbtree *tree, 
							  cp_destructor_fn key_dtr,
							  cp_destructor_fn val_dtr)
{
	tree->mode |= COLLECTION_MODE_DEEP;
	tree->key_dtr = key_dtr;
	tree->value_dtr = val_dtr;
	cp_rbtree_destroy(tree);
}

static int cp_rbtree_lock_internal(cp_rbtree *tree, int type)
{
    int rc;

    switch (type)
    {
        case COLLECTION_LOCK_READ:
            rc = cp_lock_rdlock(tree->lock);
            break;

        case COLLECTION_LOCK_WRITE:
            rc = cp_lock_wrlock(tree->lock);
            break;

        case COLLECTION_LOCK_NONE:
            rc = 0;
            break;

        default:
            rc = EINVAL;
            break;
    }

	/* api functions may rely on errno to report locking failure */
	if (rc) errno = rc;

    return rc;
}

static int cp_rbtree_unlock_internal(cp_rbtree *tree)
{
	return cp_lock_unlock(tree->lock);
}

int cp_rbtree_txlock(cp_rbtree *tree, int type)
{
	/* clear errno to allow client code to distinguish between a NULL return
	 * value indicating the tree doesn't contain the requested value and NULL
	 * on locking failure in tree operations
	 */
	if (tree->mode & COLLECTION_MODE_NOSYNC) return 0;
	if (tree->mode & COLLECTION_MODE_IN_TRANSACTION && 
		tree->txtype == COLLECTION_LOCK_WRITE)
	{
		cp_thread self = cp_thread_self();
		if (cp_thread_equal(self, tree->txowner)) return 0;
	}
	errno = 0;
	return cp_rbtree_lock_internal(tree, type);
}

int cp_rbtree_txunlock(cp_rbtree *tree)
{
	if (tree->mode & COLLECTION_MODE_NOSYNC) return 0;
	if (tree->mode & COLLECTION_MODE_IN_TRANSACTION && 
		tree->txtype == COLLECTION_LOCK_WRITE)
	{
		cp_thread self = cp_thread_self();
		if (cp_thread_equal(self, tree->txowner)) return 0;
	}
	return cp_rbtree_unlock_internal(tree);
}

/* lock and set the transaction indicators */
int cp_rbtree_lock(cp_rbtree *tree, int type)
{
	int rc;
	if ((tree->mode & COLLECTION_MODE_NOSYNC)) return EINVAL;
	if ((rc = cp_rbtree_lock_internal(tree, type))) return rc;
	tree->txtype = type;
	tree->txowner = cp_thread_self();
	tree->mode |= COLLECTION_MODE_IN_TRANSACTION;
	return 0;
}

/* unset the transaction indicators and unlock */
int cp_rbtree_unlock(cp_rbtree *tree)
{
	cp_thread self = cp_thread_self();
	if (tree->txowner == self)
	{
		tree->txowner = 0;
		tree->txtype = 0;
		tree->mode ^= COLLECTION_MODE_IN_TRANSACTION;
	}
	else if (tree->txtype == COLLECTION_LOCK_WRITE)
		return -1;
	return cp_rbtree_unlock_internal(tree);
}

/* set mode bits on the tree mode indicator */
int cp_rbtree_set_mode(cp_rbtree *tree, int mode)
{
	int rc;
	int nosync; 

	/* can't set NOSYNC in the middle of a transaction */
	if ((tree->mode & COLLECTION_MODE_IN_TRANSACTION) && 
		(mode & COLLECTION_MODE_NOSYNC)) return EINVAL;
	/* COLLECTION_MODE_MULTIPLE_VALUES must be set at creation time */	
	if (mode & COLLECTION_MODE_MULTIPLE_VALUES) return EINVAL;

	if ((rc = cp_rbtree_txlock(tree, COLLECTION_LOCK_WRITE))) return rc;
	
	nosync = tree->mode & COLLECTION_MODE_NOSYNC;

	tree->mode |= mode;

	if (!nosync)
		cp_rbtree_txunlock(tree);

	return 0;
}

/* unset mode bits on the tree mode indicator. if unsetting 
 * COLLECTION_MODE_NOSYNC and the tree was not previously synchronized, the 
 * internal synchronization structure is initialized.
 */
int cp_rbtree_unset_mode(cp_rbtree *tree, int mode)
{
	int rc;
	int nosync;

	/* COLLECTION_MODE_MULTIPLE_VALUES can't be unset */
	if (mode & COLLECTION_MODE_MULTIPLE_VALUES) return EINVAL;

	if ((rc = cp_rbtree_txlock(tree, COLLECTION_LOCK_WRITE))) return rc;
	
	nosync = tree->mode & COLLECTION_MODE_NOSYNC;

	/* handle the special case of unsetting COLLECTION_MODE_NOSYNC */
	if ((mode & COLLECTION_MODE_NOSYNC) && tree->lock == NULL)
	{
		/* tree can't be locked in this case, no need to unlock on failure */
		if ((tree->lock = malloc(sizeof(cp_lock))) == NULL)
			return -1;
		if (cp_lock_init(tree->lock, NULL))
			return -1;
	}
	
	/* unset specified bits */
    tree->mode &= tree->mode ^ mode;
	if (!nosync)
		cp_rbtree_txunlock(tree);

	return 0;
}

int cp_rbtree_get_mode(cp_rbtree *tree)
{
    return tree->mode;
}


static cp_rbnode *sibling(cp_rbnode *node)
{
	return node == node->up->left ? node->up->right : node->up->left;
}

static int is_right_child(cp_rbnode *node)
{
	return (node->up->right == node);
}

static int is_left_child(cp_rbnode *node)
{
	return (node->up->left == node);
}

/*         left rotate
 *
 *    (P)                (Q)
 *   /   \              /   \
 *  1    (Q)    ==>   (P)    3
 *      /   \        /   \
 *     2     3      1     2
 *
 */
static void rb_left_rotate(cp_rbtree *tree, cp_rbnode *p)
{
	cp_rbnode *q = p->right;
	cp_rbnode **sup;
	
	if (p->up)
		sup = is_left_child(p) ? &(p->up->left) : &(p->up->right);
	else
		sup = &tree->root;

	p->right = q->left;
	if (p->right) p->right->up = p;
	q->left = p;
	q->up = p->up;
	p->up = q;
	*sup = q;
}

/*           right rotate
 *  
 *       (P)                (Q)
 *      /   \              /   \
 *    (Q)    3    ==>     1    (P)  
 *   /   \                    /   \
 *  1     2                  2     3
 *
 */
void rb_right_rotate(cp_rbtree *tree, cp_rbnode *p)
{
	cp_rbnode *q = p->left;
	cp_rbnode **sup;
	
	if (p->up)
		sup = is_left_child(p) ? &(p->up->left) : &(p->up->right);
	else
		sup = &tree->root;

	p->left = q->right;
	if (p->left) p->left->up = p;
	q->right = p;
	q->up = p->up;
	p->up = q;
	*sup = q;
}


/*
 * newly entered node is RED; check balance recursively as required 
 */
static void rebalance(cp_rbtree *tree, cp_rbnode *node)
{
	cp_rbnode *up = node->up;
	if (up == NULL || up->color == RB_BLACK) return;
	if (sibling(up) && sibling(up)->color == RB_RED)
	{
		up->color = RB_BLACK;
		sibling(up)->color = RB_BLACK;
		if (up->up->up)
		{
			up->up->color = RB_RED;
			rebalance(tree, up->up);
		}
	}
	else
	{
		if (is_left_child(node) && is_right_child(up))
		{
			rb_right_rotate(tree, up);
			node = node->right;
		}
		else if (is_right_child(node) && is_left_child(up))
		{
		        rb_left_rotate(tree, up);
			node = node->left;
		}

		node->up->color = RB_BLACK;
		node->up->up->color = RB_RED;

		if (is_left_child(node)) // && is_left_child(node->up)
			rb_right_rotate(tree, node->up->up);
		else 
			rb_left_rotate(tree, node->up->up);
	}
}

/* update_rbnode - implement COLLECTION_MODE_COPY, COLLECTION_MODE_DEEP and
 * COLLECTION_MODE_MULTIPLE_VALUES when inserting a value for an existing key
 */
static void *
	update_rbnode(cp_rbtree *tree, cp_rbnode *node, void *key, void *value)
{
	void *new_key = key;
	void *new_value = value;

	if (tree->mode & COLLECTION_MODE_COPY)
	{
		if (tree->key_copy) 
		{
			new_key = (*tree->key_copy)(key);
			if (new_key == NULL) return NULL;
		}
		if (tree->value_copy)
		{
			new_value = (*tree->value_copy)(value);
			if (new_value == NULL) return NULL;
		}
	}

	if (tree->mode & COLLECTION_MODE_DEEP)
	{
		if (tree->key_dtr)
			(*tree->key_dtr)(node->key);
		if (tree->value_dtr && !(tree->mode & COLLECTION_MODE_MULTIPLE_VALUES))
			(*tree->value_dtr)(node->value);
	}
		
	node->key = new_key;
	if (!tree->mode & COLLECTION_MODE_MULTIPLE_VALUES)
		node->value = new_value;
	else
	{
		cp_vector_add_element(node->value, new_value);
		return node->value;
	}

	return new_value;
}

/*
 * cp_rbtree_insert iterates through the tree, finds where the new node fits
 * in, puts it there, then calls rebalance. 
 *
 * If a mapping for the given key already exists it is replaced unless 
 * COLLECTION_MODE_MULTIPLE_VALUES is set, is which case a new mapping is 
 * added. By default COLLECTION_MODE_MULTIPLE_VALUES is not set.
 */
void *cp_rbtree_insert(cp_rbtree *tree, void *key, void *value)
{
	void *res = NULL;
	
	if (cp_rbtree_txlock(tree, COLLECTION_LOCK_WRITE)) return NULL;

	if (tree->root == NULL)
	{
		tree->root = create_rbnode(tree, key, value);
		if (tree->root == NULL) goto DONE;
		res = value;
		tree->root->color = RB_BLACK;
		tree->items++;
	}
	else
	{
		int cmp;
		cp_rbnode **curr = &tree->root;
		cp_rbnode *prev = NULL;

		while (*curr)
		{
			prev = *curr;
			cmp = (*tree->cmp)((*curr)->key, key);
			if (cmp < 0)
				curr = &(*curr)->right;
			else if (cmp > 0) 
				curr = &(*curr)->left;
			else /* replace */
			{
				res = update_rbnode(tree, *curr, key, value);
				break;
			}
		}

		if (*curr == NULL) /* not replacing, create new node */
		{
			*curr = create_rbnode(tree, key, value);
			if (*curr == NULL) goto DONE;
			res = (*curr)->value;
			tree->items++;
			(*curr)->up = prev;
			rebalance(tree, *curr);
		}
	}

DONE:
	cp_rbtree_txunlock(tree);
	return res;
}

/* cp_rbtree_get - return the value mapped to the given key or NULL if none is
 * found. If COLLECTION_MODE_MULTIPLE_VALUES is set the returned value is a
 * cp_vector object or NULL if no mapping is found. 
 */
void *cp_rbtree_get(cp_rbtree *tree, void *key)
{
	cp_rbnode *curr;
	void *value = NULL;
	
	if (cp_rbtree_txlock(tree, COLLECTION_LOCK_READ)) return NULL;

	curr = tree->root;
	while (curr)
	{
		int c = tree->cmp(curr->key, key);
		if (c == 0) return curr->value;
		curr = (c > 0) ? curr->left : curr ->right;
	}

	if (curr) value = curr->value;

	cp_rbtree_txunlock(tree);
	return value;;
}
	
int cp_rbtree_contains(cp_rbtree *tree, void *key)
{
	return (cp_rbtree_get(tree, key) != NULL);
}

/* helper function for deletion */
static void rb_swap_node_content(cp_rbnode *a, cp_rbnode *b)
{
	void *tmpkey, *tmpval;

	tmpkey = a->key;
	a->key = b->key;
	b->key = tmpkey;
	
	tmpval = a->value;
	a->value = b->value;
	b->value = tmpval;
}

/*
 * helper function for cp_rbtree_delete to remove nodes with either a left 
 * NULL branch or a right NULL branch
 */
static void rb_unlink(cp_rbtree *tree, cp_rbnode *node)
{
	if (node->left)
	{
		node->left->up = node->up;
		if (node->up)
		{
			if (is_left_child(node))
				node->up->left = node->left;
			else
				node->up->right = node->left;
		}
		else
			tree->root = node->left;
	}
	else
	{
		if (node->right) node->right->up = node->up;
		if (node->up)
		{
			if (is_left_child(node))
				node->up->left = node->right;
			else
				node->up->right = node->right;
		}
		else
			tree->root = node->right;
	}
}

/* delete_rebalance - perform rebalancing after a deletion */
static void delete_rebalance(cp_rbtree *tree, cp_rbnode *n)
{
	if (n->up)
	{
		cp_rbnode *sibl = sibling(n);

		if (sibl->color == RB_RED)
		{
			n->up->color = RB_RED;
			sibl->color = RB_BLACK;
			if (is_left_child(n))
			  rb_left_rotate(tree, n->up);
			else
			  rb_right_rotate(tree, n->up);
			sibl = sibling(n);
		}

		if (n->up->color == RB_BLACK &&
			sibl->color == RB_BLACK &&
			(sibl->left == NULL || sibl->left->color == RB_BLACK) &&
			(sibl->right == NULL || sibl->right->color == RB_BLACK))
		  {
		    sibl->color = RB_RED;
			delete_rebalance(tree, n->up);
		}
		else
		{
			if (n->up->color == RB_RED &&
				sibl->color == RB_BLACK &&
				(sibl->left == NULL || sibl->left->color == RB_BLACK) &&
				(sibl->right == NULL || sibl->right->color == RB_BLACK))
			{
				sibl->color = RB_RED;
				n->up->color = RB_BLACK;
			}
			else
			{
				if (is_left_child(n) && 
					sibl->color == RB_BLACK &&
					sibl->left && sibl->left->color == RB_RED && 
					(sibl->right == NULL || sibl->right->color == RB_BLACK))
				{
					sibl->color = RB_RED;
					sibl->left->color = RB_BLACK;
					rb_right_rotate(tree, sibl);					
					sibl = sibling(n);
				}
				else if (is_right_child(n) &&
					sibl->color == RB_BLACK &&
					sibl->right && sibl->right->color == RB_RED &&
					(sibl->left == NULL || sibl->left->color == RB_BLACK))
				{
					sibl->color = RB_RED;
					sibl->right->color = RB_BLACK;
					rb_left_rotate(tree, sibl);
					sibl = sibling(n);
				}

				sibl->color = n->up->color;
				n->up->color = RB_BLACK;
				if (is_left_child(n))
				{
				  sibl->right->color = RB_BLACK;
				  rb_left_rotate(tree, n->up);
				}
				else
				{
				  sibl->left->color = RB_BLACK;
				  rb_right_rotate(tree, n->up);
				}
			}
		}
	}
}

/* cp_rbtree_delete_impl - delete one node from a red black tree */
void *cp_rbtree_delete_impl(cp_rbtree *tree, void *key)
{
	void *res = NULL;
	cp_rbnode *node; 
	int cmp;

	node = tree->root;
	while (node)
	{
		cmp = (*tree->cmp)(node->key, key);
		if (cmp < 0)
			node = node->right;
		else if (cmp > 0)
			node = node->left;
		else /* found */
			break;
	}

	if (node) /* may be null if not found */
	{
		cp_rbnode *child; 
		res = node->value;
		tree->items--;

		if (node->right && node->left)
		{
			cp_rbnode *surrogate = node;
			node = node->right;
			while (node->left) node = node->left;
			rb_swap_node_content(node, surrogate);
		}
		child = node->right ? node->right : node->left;

		/* if the node was red - no rebalancing required */
		if (node->color == RB_BLACK)
		{
			if (child)
			{
				/* single red child - paint it black */
				if (child->color == RB_RED)
					child->color = RB_BLACK; /* and the balance is restored */
				else
					delete_rebalance(tree, child);
			}
			else 
				delete_rebalance(tree, node);
		}

		rb_unlink(tree, node);
		cp_rbtree_destroy_node(tree, node);
	}

	return res;
}

/* cp_rbtree_delete - deletes the value mapped to the given key from the tree
 * and returns the value removed. 
 */
void *cp_rbtree_delete(cp_rbtree *tree, void *key)
{
	void *res = NULL;

	if (cp_rbtree_txlock(tree, COLLECTION_LOCK_WRITE)) return NULL;

	res = cp_rbtree_delete_impl(tree, key);

	cp_rbtree_txunlock(tree);
	return res;
}

static int 
	rb_scan_pre_order(cp_rbnode *node, cp_callback_fn callback, void *prm)
{
	int rc;
	
	if (node) 
	{
		if ((rc = (*callback)(node, prm))) return rc;
		if ((rc = rb_scan_pre_order(node->left, callback, prm))) return rc;
		if ((rc = rb_scan_pre_order(node->right, callback, prm))) return rc;
	}

	return 0;
}

int cp_rbtree_callback_preorder(cp_rbtree *tree, 
								cp_callback_fn callback, 
								void *prm)
{
	int rc;

	if ((rc = cp_rbtree_txlock(tree, COLLECTION_LOCK_READ))) return rc;
	rc = rb_scan_pre_order(tree->root, callback, prm);
	cp_rbtree_txunlock(tree);

	return rc;
}

static int 
	rb_scan_in_order(cp_rbnode *node, cp_callback_fn callback, void *prm)
{
	int rc;
	
	if (node) 
	{
		if ((rc = rb_scan_in_order(node->left, callback, prm))) return rc;
		if ((rc = (*callback)(node, prm))) return rc;
		if ((rc = rb_scan_in_order(node->right, callback, prm))) return rc;
	}

	return 0;
}

int cp_rbtree_callback(cp_rbtree *tree, cp_callback_fn callback, void *prm)
{
	int rc;

	if ((rc = cp_rbtree_txlock(tree, COLLECTION_LOCK_READ))) return rc;
	rc = rb_scan_in_order(tree->root, callback, prm);
	cp_rbtree_txunlock(tree);

	return rc;
}

static int 
	rb_scan_post_order(cp_rbnode *node, cp_callback_fn callback, void *prm)
{
	int rc;
	
	if (node) 
	{
		if ((rc = rb_scan_post_order(node->left, callback, prm))) return rc;
		if ((rc = rb_scan_post_order(node->right, callback, prm))) return rc;
		if ((rc = (*callback)(node, prm))) return rc;
	}

	return 0;
}

int cp_rbtree_callback_postorder(cp_rbtree *tree, 
								 cp_callback_fn callback, 
								 void *prm)
{
	int rc;

	if ((rc = cp_rbtree_txlock(tree, COLLECTION_LOCK_READ))) return rc;
	rc = rb_scan_post_order(tree->root, callback, prm);
	cp_rbtree_txunlock(tree);

	return rc;
}

int cp_rbtree_count(cp_rbtree *tree)
{
	return tree->items;
}


void cp_rbnode_print(cp_rbnode *node, int level)
{
	int i;
	if (node->right) cp_rbnode_print(node->right, level + 1);
	for (i = 0; i < level; i++) printf("  . ");
	printf("(%d) [%s => %s]\n", node->color, (char *) node->key, (char *) node->value);
	if (node->left) cp_rbnode_print(node->left, level + 1);
}

void cp_rbnode_multi_print(cp_rbnode *node, int level)
{
	int i;
	cp_vector *v = node->value;
	if (node->right) cp_rbnode_multi_print(node->right, level + 1);
	
	for (i = 0; i < level; i++) printf("  . ");
	printf("(%d) [%s => ", node->color, (char *) node->key);

	for (i = 0; i < cp_vector_size(v); i++)
		printf("%s; ", (char *) cp_vector_element_at(v, i));

	printf("]\n");

	if (node->left) cp_rbnode_multi_print(node->left, level + 1);
}

void cp_rbtree_dump(cp_rbtree *tree)
{
	if (tree->root) 
	{
		if (tree->mode & COLLECTION_MODE_MULTIPLE_VALUES)
			cp_rbnode_multi_print(tree->root, 0);
		else
			cp_rbnode_print(tree->root, 0);
	}
}

/* set tree to use given mempool or allocate a new one if pool is NULL */
int cp_rbtree_use_mempool(cp_rbtree *tree, cp_mempool *pool)
{
	int rc = 0;
	
	if ((rc = cp_rbtree_txlock(tree, COLLECTION_LOCK_WRITE))) return rc;
	
	if (pool)
	{
		if (pool->item_size < sizeof(cp_rbnode))
		{
			rc = EINVAL;
			goto DONE;
		}
		if (tree->mempool) 
		{
			if (tree->items) 
			{
				rc = ENOTEMPTY;
				goto DONE;
			}
			cp_mempool_destroy(tree->mempool);
		}
		cp_mempool_inc_refcount(pool);
		tree->mempool = pool;
	}
	else
	{
		tree->mempool = 
			cp_mempool_create_by_option(COLLECTION_MODE_NOSYNC, 
										sizeof(cp_rbnode), 0);
		if (tree->mempool == NULL) 
		{
			rc = ENOMEM;
			goto DONE;
		}
	}

DONE:
	cp_rbtree_txunlock(tree);
	return rc;
}


/* set tree to use a shared memory pool */
int cp_rbtree_share_mempool(cp_rbtree *tree, cp_shared_mempool *pool)
{
	int rc;

	if ((rc = cp_rbtree_txlock(tree, COLLECTION_LOCK_WRITE))) return rc;

	if (tree->mempool)
	{
		if (tree->items)
		{
			rc = ENOTEMPTY;
			goto DONE;
		}

		cp_mempool_destroy(tree->mempool);
	}

	tree->mempool = cp_shared_mempool_register(pool, sizeof(cp_rbnode));
	if (tree->mempool == NULL) 
	{
		rc = ENOMEM;
		goto DONE;
	}
	
DONE:
	cp_rbtree_txunlock(tree);
	return rc;
}



/*************************  vector *****************************************/

/**
 * cp_vector is a 'safe array' implementation
 */

#include <stdlib.h>
#include <string.h>
#include <errno.h>

cp_vector *cp_vector_create_by_option(int size, 
									  int mode, 
									  cp_copy_fn copy_item,
									  cp_destructor_fn free_item)
{
	cp_vector *v = calloc(1, sizeof(cp_vector));
	if (v == NULL) 
	{
		errno = ENOMEM;
		return NULL;
	}

	v->mem = calloc(size, sizeof(void *));
	if (v->mem == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	v->size = size;
	v->mode = mode;
	v->copy_item = copy_item;
	v->free_item = free_item;
	v->head = v->tail = 0;

	return v;
}

cp_vector *cp_vector_create(int size)
{
	return cp_vector_create_by_option(size, 0, NULL, NULL);
}

cp_vector *cp_vector_wrap(void **data, int len, int mode)
{
	cp_vector *v = calloc(1, sizeof(cp_vector));
	if (v == NULL) return NULL;

	v->mem = data;
	v->size = len;
	v->mode = mode;
	v->head = len;
	v->tail = 0;

	return v;
}

void cp_vector_destroy(cp_vector *v)
{
	if (v)
	{
		if ((v->mode & COLLECTION_MODE_DEEP) && v->free_item != NULL)
		{
			int i;
			int n = cp_vector_size(v);
			void *item;
			for (i = 0; i < n; i++)
			{
				item = cp_vector_element_at(v, i);
				if (item) (*v->free_item)(item);
			}
		}
		free(v->mem);
		free(v);
	}
}

void cp_vector_destroy_custom(cp_vector *v, cp_destructor_fn dtr)
{
	if (v)
	{
		int i;
		int n = cp_vector_size(v);

		if (dtr)
		{
			for (i = 0; i < n; i++)
				if (v->mem[i]) (*dtr)(v->mem[i]);
		}
	
		free(v->mem);
		free(v);
	}
}

void *cp_vector_element_at(cp_vector *v, int index)
{
	return index >= 0 && index <= cp_vector_size(v) ? v->mem[index] : NULL;
}

void *cp_vector_set_element(cp_vector *v, int index, void *element)
{
	if (index < 0)
	{
		errno = EINVAL;
		return NULL;
	}

	if (index >= v->head)
		v->head = index + 1;

	if (v->head >= v->size)
	{
		v->size = index + 2;
		v->mem = realloc(v->mem, v->size * sizeof(void *));
	}

	if ((v->mode & COLLECTION_MODE_DEEP) && 
			v->mem[index] != NULL && v->free_item != NULL)
		(*v->free_item)(v->mem[index]);

	if ((v->mode & COLLECTION_MODE_COPY) && element != NULL && v->copy_item != NULL)
		v->mem[index] = (*v->copy_item)(element);
	else
		v->mem[index] = element;
	
	return element;
}

void *cp_vector_add_element(cp_vector *v, void *element)
{
	void *addr = NULL;

	if (v->head + 1 >= v->tail + v->size)
	{
		void **newptr = realloc(v->mem, 2 * v->size * sizeof(void *));
		if (newptr == NULL) return NULL;
		v->mem = newptr;
		if (v->head < v->tail)
		{
			memcpy(v->mem, &v->mem[v->size], v->head * sizeof(void *));
			v->head += v->size;
		}
		v->size *= 2;
	}
			
	if (v->mode & COLLECTION_MODE_COPY)
		v->mem[v->head] = (*v->copy_item)(element);
	else
		v->mem[v->head] = element;
	addr = v->mem[v->head];
	v->head = (v->head + 1) % v->size;

	return addr;
}

int cp_vector_size(cp_vector *v)
{
	return (v->head - v->tail + v->size) % v->size;
}













/**************************  splay tree *************************************/


#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

cp_splaynode *cp_splaynode_create(void *key, void *value, cp_mempool *pool)
{
	cp_splaynode *node;
	if (pool) 
		node = cp_mempool_calloc(pool);
	else
		node = calloc(1, sizeof(cp_splaynode));
	if (node == NULL) return NULL;

	node->key = key;
	node->value = value;

	return node;
}
	
void cp_splaytree_destroy_node(cp_splaytree *tree, cp_splaynode *node)
{
	if (node)
	{
		if ((tree->mode & COLLECTION_MODE_DEEP))
		{
			if (tree->key_dtr) (*tree->key_dtr)(node->key);
			if ((tree->mode & COLLECTION_MODE_MULTIPLE_VALUES) && node->value)
				cp_vector_destroy_custom(node->value, tree->value_dtr);
			else if (tree->value_dtr) 
				(*tree->value_dtr)(node->value);
		}
		else if ((tree->mode & COLLECTION_MODE_MULTIPLE_VALUES) && node->value)
			cp_vector_destroy(node->value);
		if (tree->mempool)
			cp_mempool_free(tree->mempool, node);
		else
			free(node);
	}
}

void cp_splaytree_destroy_node_deep(cp_splaytree *tree, cp_splaynode *node)
{
	if (node)
	{
		cp_splaynode *parent;
		cp_splaynode *child;

		parent = node;
		while (node)
		{
			if (node->right && node->right != parent)
			{
				child = node->right;
				node->right = parent;
				parent = node;
				node = child;
			}
			else if (node->left && node->left != parent)
			{
				child = node->left;
				node->left = node->right;
				node->right = parent;
				parent = node;
				node = child;
			}
			else
			{
				cp_splaytree_destroy_node(tree, node);
				if (node != parent)
				{
					node = parent;
					parent = node->right;
				}
				else
					break;
			}
		}
	}
}

cp_splaytree *cp_splaytree_create(cp_compare_fn cmp)
{
	cp_splaytree *tree = calloc(1, sizeof(cp_splaytree));
	if (tree == NULL) return NULL;

	tree->cmp = cmp;
	tree->mode = COLLECTION_MODE_NOSYNC;

	return tree;
}

/*
 * complete parameter create function
 */
cp_splaytree *
	cp_splaytree_create_by_option(int mode, 
								  cp_compare_fn cmp, 
								  cp_copy_fn key_copy, 
								  cp_destructor_fn key_dtr,
								  cp_copy_fn val_copy, 
								  cp_destructor_fn val_dtr)
{
	cp_splaytree *tree = cp_splaytree_create(cmp);
	if (tree == NULL) return NULL;
	
	tree->mode = mode;
	tree->key_copy = key_copy;
	tree->key_dtr = key_dtr;
	tree->value_copy = val_copy;
	tree->value_dtr = val_dtr;

	if (!(mode & COLLECTION_MODE_NOSYNC))
	{
		tree->lock = malloc(sizeof(cp_lock));
		if (tree->lock == NULL) 
		{
			cp_splaytree_destroy(tree);
			return NULL;
		}
		if (cp_lock_init(tree->lock, NULL) != 0)
		{
			cp_splaytree_destroy(tree);
			return NULL;
		}
	}

	return tree;
}

void cp_splaytree_destroy(cp_splaytree *tree)
{
	if (tree)
	{
		cp_splaytree_destroy_node_deep(tree, tree->root);
		if (tree->lock)
		{
			cp_lock_destroy(tree->lock);
			free(tree->lock);
		}
		free(tree);
	}
}

void cp_splaytree_destroy_custom(cp_splaytree *tree, 
							     cp_destructor_fn key_dtr,
							     cp_destructor_fn val_dtr)
{
	tree->mode |= COLLECTION_MODE_DEEP;
	tree->key_dtr = key_dtr;
	tree->value_dtr = val_dtr;
	cp_splaytree_destroy(tree);
}

static int cp_splaytree_lock_internal(cp_splaytree *tree, int type)
{
    int rc;

    switch (type)
    {
        case COLLECTION_LOCK_READ:
            rc = cp_lock_rdlock(tree->lock);
            break;

        case COLLECTION_LOCK_WRITE:
            rc = cp_lock_wrlock(tree->lock);
            break;

        case COLLECTION_LOCK_NONE:
            rc = 0;
            break;

        default:
            rc = EINVAL;
            break;
    }

	/* api functions may rely on errno to report locking failure */
	if (rc) errno = rc;

    return rc;
}

static int cp_splaytree_unlock_internal(cp_splaytree *tree)
{
	return cp_lock_unlock(tree->lock);
}

int cp_splaytree_txlock(cp_splaytree *tree, int type)
{
	/* clear errno to allow applications to detect locking failure */
	errno = 0;
	
	if (tree->mode & COLLECTION_MODE_NOSYNC) return 0;
	if (tree->mode & COLLECTION_MODE_IN_TRANSACTION && 
		tree->txtype == COLLECTION_LOCK_WRITE)
	{
		cp_thread self = cp_thread_self();
		if (cp_thread_equal(self, tree->txowner)) return 0;
	}
	return cp_splaytree_lock_internal(tree, type);
}

int cp_splaytree_txunlock(cp_splaytree *tree)
{
	if (tree->mode & COLLECTION_MODE_NOSYNC) return 0;
	if (tree->mode & COLLECTION_MODE_IN_TRANSACTION && 
		tree->txtype == COLLECTION_LOCK_WRITE)
	{
		cp_thread self = cp_thread_self();
		if (cp_thread_equal(self, tree->txowner)) return 0;
	}
	return cp_splaytree_unlock_internal(tree);
}

/* lock and set the transaction indicators */
int cp_splaytree_lock(cp_splaytree *tree, int type)
{
	int rc;
	if ((tree->mode & COLLECTION_MODE_NOSYNC)) return EINVAL;
	if ((rc = cp_splaytree_lock_internal(tree, type))) return rc;
	tree->txtype = type;
	tree->txowner = cp_thread_self();
	tree->mode |= COLLECTION_MODE_IN_TRANSACTION;
	return 0;
}

/* unset the transaction indicators and unlock */
int cp_splaytree_unlock(cp_splaytree *tree)
{
	cp_thread self = cp_thread_self();
	if (tree->txowner == self)
	{
		tree->txowner = 0;
		tree->txtype = 0;
		tree->mode ^= COLLECTION_MODE_IN_TRANSACTION;
	}
	else if (tree->txtype == COLLECTION_LOCK_WRITE)
		return -1;
	return cp_splaytree_unlock_internal(tree);
}

/* set mode bits on the tree mode indicator */
int cp_splaytree_set_mode(cp_splaytree *tree, int mode)
{
	int rc;
	int nosync; 

	/* can't set NOSYNC in the middle of a transaction */
	if ((tree->mode & COLLECTION_MODE_IN_TRANSACTION) && 
		(mode & COLLECTION_MODE_NOSYNC)) return EINVAL;
	/* COLLECTION_MODE_MULTIPLE_VALUES must be set at creation time */	
	if (mode & COLLECTION_MODE_MULTIPLE_VALUES) return EINVAL;

	if ((rc = cp_splaytree_txlock(tree, COLLECTION_LOCK_WRITE))) return rc;
	
	nosync = tree->mode & COLLECTION_MODE_NOSYNC;

	tree->mode |= mode;

	if (!nosync)
		cp_splaytree_txunlock(tree);

	return 0;
}

/* unset mode bits on the tree mode indicator. if unsetting 
 * COLLECTION_MODE_NOSYNC and the tree was not previously synchronized, the 
 * internal synchronization structure is initalized.
 */
int cp_splaytree_unset_mode(cp_splaytree *tree, int mode)
{
	int rc;
	int nosync;

	/* COLLECTION_MODE_MULTIPLE_VALUES can't be unset */
	if (mode & COLLECTION_MODE_MULTIPLE_VALUES) return EINVAL;

	if ((rc = cp_splaytree_txlock(tree, COLLECTION_LOCK_WRITE))) return rc;
	
	nosync = tree->mode & COLLECTION_MODE_NOSYNC;

	/* handle the special case of unsetting COLLECTION_MODE_NOSYNC */
	if ((mode & COLLECTION_MODE_NOSYNC) && tree->lock == NULL)
	{
		/* tree can't be locked in this case, no need to unlock on failure */
		if ((tree->lock = malloc(sizeof(cp_lock))) == NULL)
			return -1; 
		if (cp_lock_init(tree->lock, NULL))
			return -1;
	}
	
	/* unset specified bits */
    tree->mode &= tree->mode ^ mode;
	if (!nosync)
		cp_splaytree_txunlock(tree);

	return 0;
}

int cp_splaytree_get_mode(cp_splaytree *tree)
{
    return tree->mode;
}


/*  right_rotate - the splay 'zig' operation
 * 
 *       (P)                (Q)
 *      /   \              /   \
 *    (Q)    3    ==>     1    (P)  
 *   /   \                    /   \
 *  1     2                  2     3
 *
 */
void right_rotate(cp_splaynode **node)
{
	cp_splaynode *p = *node;
	cp_splaynode *q = p->left;
	p->left = q->right;
	q->right = p;
	*node = q;
}

/*  left_rotate - the splay 'zag' operation
 * 
 *    (P)                (Q)
 *   /   \              /   \
 *  1    (Q)    ==>   (P)    3
 *      /   \        /   \
 *     2     3      1     2
 *
 */
void left_rotate(cp_splaynode **node)
{
        printf("in left rotate\n");
	cp_splaynode *p = *node;
	cp_splaynode *q = p->right;

	//niloo
        assert(q);

	p->right = q->left;
	q->left = p;
	*node = q;
}

/*  left-right rotate - the splay 'zig-zag' operation
 * 
 *          (P)                (R)
 *         /   \              /   \
 *      (Q)     4   ==>     (Q)    (P)  
 *      / \                /  \    /  \
 *     1  (R)             1    2  3    4
 *        / \
 *       2   3
 *
 */
static void left_right_rotate(cp_splaynode **node)
{
	cp_splaynode *p = *node;
	cp_splaynode *q = (*node)->left;
	cp_splaynode *r = q->right;

	q->right = r->left;
	p->left = r->right;
	r->right = p;
	r->left = q;

	*node = r;
}

/*  right-left rotate - the splay 'zag-zig' operation
 * 
 *          (P)                   (R)
 *         /   \                 /   \
 *        1     (Q)     ==>    (P)    (Q)  
 *             /  \           /  \    /  \
 *           (R)   4         1    2  3    4
 *           / \
 *          2   3
 *
 */
static void right_left_rotate(cp_splaynode **node)
{
	cp_splaynode *p = *node;
	cp_splaynode *q = (*node)->right;
	cp_splaynode *r = q->left;

	q->left = r->right;
	p->right = r->left;
	r->left = p;
	r->right = q;

	*node = r;
}

/* implement COLLECTION_MODE_COPY, COLLECTION_MODE_MULTIPLE_VALUES if set */
static cp_splaynode *
	create_splaynode(cp_splaytree *tree, void *key, void *value)
{
	cp_splaynode *node = NULL;


	if (tree->mode & COLLECTION_MODE_COPY)
	{
		void *k = tree->key_copy ? (*tree->key_copy)(key) : key;
		if (k)
		{
             		void *v = tree->value_copy ? (*tree->value_copy)(value) : value;
			if (v){
				node = cp_splaynode_create(k, v, tree->mempool);
		
			}
		}
	}
	else{
		node = cp_splaynode_create(key, value, tree->mempool);
	}

	if (node && tree->mode & COLLECTION_MODE_MULTIPLE_VALUES)
	{
		cp_vector *m = cp_vector_create(1);
		if (m == NULL) 
		{
			cp_splaytree_destroy_node(tree, node);
			return NULL;
		}

		cp_vector_add_element(m, node->value);
		node->value = m;
	}

	return node;
}

/* update_splaynode - implement COLLECTION_MODE_COPY, COLLECTION_MODE_DEEP and
 * COLLECTION_MODE_MULTIPLE_VALUES when inserting a value for an existing key
 */
static void *
	update_splaynode(cp_splaytree *tree, 
					 cp_splaynode *node, 
					 void *key, void *value)
{
	void *new_key = key;
	void *new_value = value;

	if (tree->mode & COLLECTION_MODE_COPY)
	{
		if (tree->key_copy) 
		{
			new_key = (*tree->key_copy)(key);
			if (new_key == NULL) return NULL;
		}
		if (tree->value_copy)
		{
			new_value = (*tree->value_copy)(value);
			if (new_value == NULL) return NULL;
		}
	}

	if (tree->mode & COLLECTION_MODE_DEEP)
	{
		if (tree->key_dtr)
			(*tree->key_dtr)(node->key);
		if (tree->value_dtr && !(tree->mode & COLLECTION_MODE_MULTIPLE_VALUES))
			(*tree->value_dtr)(node->value);
	}
		
	node->key = new_key;
	if (tree->mode & COLLECTION_MODE_MULTIPLE_VALUES)
	{
		cp_vector_add_element(node->value, new_value);
		return node->value;
	}
	else
		node->value = new_value;

	return new_value;
}


/* desplay - the splay balancing act on recursion fold 
 *
 * cp_splaytree divides the implementation of the splay operation between
 * the tree operations, which recursively walk the tree down to the object 
 * node, and the de-splay function, which performs splay rotations on the way
 * out of the recursion
 */
static void desplay(cp_splaynode **node, int *splay_factor, int op)
{

        //niloo
        printf("in desplay\n");
        printf("(*splay_factor): %d   op:%d \n",(*splay_factor),op) ;
        //assert((*splay_factor) != NULL);
        //if((*splay_factor) == NULL){
	//	printf("errrrrrrrrrror\n");
        //	return; 
        //}


	switch (*splay_factor)
	{
		case 0: 
			*splay_factor += op;
			break;

		case -1:
			if (op == 0)
				right_rotate(node);
			else
			{
				if (op == -1)
				{
					right_rotate(node);
					right_rotate(node);
				}
				else
					right_left_rotate(node);
				*splay_factor = 0;
			}
			break;
			
		case 1:
			if (op == 0)
				left_rotate(node);
			else
			{
				if (op == 1)
				{
					left_rotate(node);
					left_rotate(node);
				}
				else
					left_right_rotate(node);
				*splay_factor = 0;
			}
			break;
	}
}

static void *
	splay_insert(cp_splaytree *tree, 
			     cp_splaynode **node, 
				 void *key, void *value,
				 int *splay_factor)
{
	int cmp;
	void *res;
	
	if (*node == NULL)
	{
		printf("create\n");	
		*node = create_splaynode(tree, key, value);
		if (*node) 
		{
			tree->items++;
			return (*node)->value;
		}
		return NULL;
	}

	res = (*node)->value;
		
	cmp = tree->cmp((*node)->key, key);
	if (cmp == 0)	/* replace */
	{
                printf("replace\n");  
		*splay_factor = 0;
		return update_splaynode(tree, *node, key, value);
	}
	else if (cmp > 0) /* go left */
	{
                printf("go left\n");
		res = splay_insert(tree, &(*node)->left, key, value, splay_factor);
		desplay(node, splay_factor, -1);
	}
	else /* go right*/
	{
		printf("go right\n");
		res = splay_insert(tree, &(*node)->right, key, value, splay_factor);
		desplay(node, splay_factor, 1);
	}
	
	return res;
}

void *cp_splaytree_insert(cp_splaytree *tree, void *key, void *value)
{
	void *res;
	int splay_factor = 0;
	
        //niloo
        //tree->opCount++; 

        printf("in insert \n");

	/* lock unless COLLECTION_MODE_NOSYNC is set or this thread owns the tx */
	if (cp_splaytree_txlock(tree, COLLECTION_LOCK_WRITE)) return NULL;
	
	res = splay_insert(tree, &tree->root, key, value, &splay_factor);
	desplay(&tree->root, &splay_factor, 0);

	/* unlock unless COLLECTION_MODE_NOSYNC set or this thread owns the tx */
	cp_splaytree_txunlock(tree);
	
	return res;
}

static void *
	splay_get(cp_splaytree *tree, 
			  cp_splaynode **node, 
			  void *key, 
			  int *splay_factor)
{
	int cmp;
	void *res;
	
	if (*node == NULL) return NULL;

	cmp = tree->cmp((*node)->key, key);
	if (cmp == 0)	/* found */
	{
		*splay_factor = 0;
		res = (*node)->value;
	}
	else if (cmp > 0) /* go left */
	{
		if ((res = splay_get(tree, &(*node)->left, key, splay_factor)))
			desplay(node, splay_factor, -1);
	}
	else /* go right*/
	{
		if ((res = splay_get(tree, &(*node)->right, key, splay_factor)))
			desplay(node, splay_factor, 1);
	}
	
	return res;
}

void *cp_splaytree_get(cp_splaytree *tree, void *key)
{
	int splay_factor = 0;
	cp_splaynode **node = &tree->root;
	void *res = NULL;

	/* the search operation on a splay tree brings the requested mapping to
	 * the root of the tree - this being the point to the splay tree data
	 * structure. Since the tree structure may change, the tree must be locked
	 * for writing here (unless COLLECTION_MODE_NOSYNC is set).
	 */
	if (cp_splaytree_txlock(tree, COLLECTION_LOCK_WRITE)) return NULL;

	res = splay_get(tree, node, key, &splay_factor);
	desplay(node, &splay_factor, 0);

	/* unlock unless COLLECTION_MODE_NOSYNC set or this thread owns the tx */
	cp_splaytree_txunlock(tree);

	return res;
}
	
int cp_splaytree_contains(cp_splaytree *tree, void *key)
{
	return (cp_splaytree_get(tree, key) != NULL);
}

/* helper function for deletion */
static void swap_node_content(cp_splaynode *a, cp_splaynode *b)
{
	void *tmpkey, *tmpval;

	tmpkey = a->key;
	a->key = b->key;
	b->key = tmpkey;
	
	tmpval = a->value;
	a->value = b->value;
	b->value = tmpval;
}

static void *
	splay_delete(cp_splaytree *tree, 
				 cp_splaynode **node,
				 void *key, 
				 int *splay_factor)
{
	void *res;
	int cmp;
	
	if ((*node) == NULL) 
	{
                printf("null\n");  
		*splay_factor = 0;
		return NULL;
	}
	
	cmp = (*tree->cmp)((*node)->key, key);
	if (cmp == 0)
	{
                printf("delete this \n"); 
		cp_splaynode *x;
		res = (*node)->value;
		tree->items--;
		
		if ((*node)->right && (*node)->left)
		{
			cp_splaynode *surrogate = *node;
			node = &(*node)->right;
			while ((*node)->left) node = &(*node)->left;
			swap_node_content(*node, surrogate);
		}

		x = *node;
		if ((*node)->right)
			*node = (*node)->right;
		else
			*node = (*node)->left;
		cp_splaytree_destroy_node(tree, x);
		
		*splay_factor = 0;
	}
	else if (cmp > 0)
	{
                printf("delete left\n");
		res = splay_delete(tree, &(*node)->left, key, splay_factor);
		desplay(node, splay_factor, -1);
	}
	else
	{
                printf("delete right\n");
  		res = splay_delete(tree, &(*node)->right, key, splay_factor);
		desplay(node, splay_factor, 1);
	}

	return res;
}
				 
void *cp_splaytree_delete(cp_splaytree *tree, void *key)
{
	void *res = NULL;
	int splay_factor = 0;
	cp_splaynode **node;

        //niloo
        //tree->opCount++; 
        printf("in delete\n");

	if (cp_splaytree_txlock(tree, COLLECTION_LOCK_WRITE)) return NULL;
	
	node = &tree->root;

	res = splay_delete(tree, node, key, &splay_factor);
	desplay(node, &splay_factor, 0);

	cp_splaytree_txunlock(tree);
	
	return res;
}


static int 
	splay_scan_pre_order(cp_splaynode *node, 
						 cp_callback_fn callback, 
						 void *prm)
{
	int rc;
	
	if (node) 
	{
		if ((rc = (*callback)(node, prm))) return rc;
		if ((rc = splay_scan_pre_order(node->right, callback, prm))) return rc;
		if ((rc = splay_scan_pre_order(node->left, callback, prm))) return rc;
	}

	return 0;
}

int cp_splaytree_callback_preorder(cp_splaytree *tree, 
								   cp_callback_fn callback, 
								   void *prm)
{
	int rc;

	if ((rc = cp_splaytree_txlock(tree, COLLECTION_LOCK_READ))) return rc;
	rc = splay_scan_pre_order(tree->root, callback, prm);
	cp_splaytree_txunlock(tree);

	return rc;
}

static int 
	splay_scan_in_order(cp_splaynode *node, cp_callback_fn callback, void *prm)
{
	int rc;
	
	if (node) 
	{
		if ((rc = splay_scan_in_order(node->right, callback, prm))) return rc;
		if ((rc = (*callback)(node, prm))) return rc;
		if ((rc = splay_scan_in_order(node->left, callback, prm))) return rc;
	}

	return 0;
}

int cp_splaytree_callback(cp_splaytree *tree, 
						  cp_callback_fn callback, 
						  void *prm)
{
	int rc;

	if ((rc = cp_splaytree_txlock(tree, COLLECTION_LOCK_READ))) return rc;
	rc = splay_scan_in_order(tree->root, callback, prm);
	cp_splaytree_txunlock(tree);

	return rc;
}

static int 
	splay_scan_post_order(cp_splaynode *node, 
						  cp_callback_fn callback, 
						  void *prm)
{
	int rc;
	
	if (node) 
	{
		if ((rc = splay_scan_post_order(node->right, callback, prm))) return rc;
		if ((rc = splay_scan_post_order(node->left, callback, prm))) return rc;
		if ((rc = (*callback)(node, prm))) return rc;
	}

	return 0;
}

int cp_splaytree_callback_postorder(cp_splaytree *tree, 
									cp_callback_fn callback, 
									void *prm)
{
	int rc;

	if ((rc = cp_splaytree_txlock(tree, COLLECTION_LOCK_READ))) return rc;
	rc = splay_scan_post_order(tree->root, callback, prm);
	cp_splaytree_txunlock(tree);

	return rc;
}

int cp_splaytree_count(cp_splaytree *tree)
{
	return tree->items;
}


void cp_splaynode_print(cp_splaynode *node, int level)
{
	int i;
	if (node->right) cp_splaynode_print(node->right, level + 1);
	for (i = 0; i < level; i++) printf("  . ");
	printf("[%s => %s]\n", (char *) node->key, (char *) node->value);
	if (node->left) cp_splaynode_print(node->left, level + 1);
}

void cp_splaynode_multi_print(cp_splaynode *node, int level)
{
	int i;
	cp_vector *v = node->value;
	if (node->right) cp_splaynode_multi_print(node->right, level + 1);
	
	for (i = 0; i < level; i++) printf("  . ");
	printf("[%s => ", (char *) node->key);

	for (i = 0; i < cp_vector_size(v); i++)
		printf("%s; ", (char *) cp_vector_element_at(v, i));

	printf("]\n");

	if (node->left) cp_splaynode_multi_print(node->left, level + 1);
}

void cp_splaytree_dump(cp_splaytree *tree)
{
	if (tree->root) 
	{
		if (tree->mode & COLLECTION_MODE_MULTIPLE_VALUES)
			cp_splaynode_multi_print(tree->root, 0);
		else
			cp_splaynode_print(tree->root, 0);
	}
}

/* set tree to use given mempool or allocate a new one if pool is NULL */
int cp_splaytree_use_mempool(cp_splaytree *tree, cp_mempool *pool)
{
	int rc = 0;
	
	if ((rc = cp_splaytree_txlock(tree, COLLECTION_LOCK_WRITE))) return rc;
	
	if (pool)
	{
		if (pool->item_size < sizeof(cp_splaynode))
		{
			rc = EINVAL;
			goto DONE;
		}
		if (tree->mempool) 
		{
			if (tree->items) 
			{
				rc = ENOTEMPTY;
				goto DONE;
			}
			cp_mempool_destroy(tree->mempool);
		}
		cp_mempool_inc_refcount(pool);
		tree->mempool = pool;
	}
	else
	{
		tree->mempool = 
			cp_mempool_create_by_option(COLLECTION_MODE_NOSYNC, 
										sizeof(cp_splaynode), 0);
		if (tree->mempool == NULL) 
		{
			rc = ENOMEM;
			goto DONE;
		}
	}

DONE:
	cp_splaytree_txunlock(tree);
	return rc;
}


/* set tree to use a shared memory pool */
int cp_splaytree_share_mempool(cp_splaytree *tree, cp_shared_mempool *pool)
{
	int rc;

	if ((rc = cp_splaytree_txlock(tree, COLLECTION_LOCK_WRITE))) return rc;

	if (tree->mempool)
	{
		if (tree->items)
		{
			rc = ENOTEMPTY;
			goto DONE;
		}

		cp_mempool_destroy(tree->mempool);
	}

	tree->mempool = cp_shared_mempool_register(pool, sizeof(cp_splaynode));
	if (tree->mempool == NULL) 
	{
		rc = ENOMEM;
		goto DONE;
	}
	
DONE:
	cp_splaytree_txunlock(tree);
	return rc;
}





















cp_rbtree *t = NULL;
pthread_mutex_t mutex, mutex_2;
int opCount = 0;
int lastInsert1, lastInsert2;

void * thread_routine(int* arg)
{

      int id = (int)arg;
      //int opcount = 0;
      int insert_count = 0;
      int delete_count = 0;
      int ncount, mode;

      printf("thread %d \n", id);

      mode = cp_rbtree_get_mode(t);

      char *x;
      char name1[80];
      int tmp;

      sprintf(name1, "hello");
      name1[strlen (name1) - 1] = '\0';	/* chop newline */


      cp_rbtree_set_mode(t, mode);


      pthread_mutex_lock(&mutex);
      if(opCount==1);
      pthread_mutex_unlock(&mutex); 

      pthread_mutex_lock(&mutex);
      if(opCount==3);
      pthread_mutex_unlock(&mutex); 
 
      cp_rbtree_insert (t, name1, name1);
      pthread_mutex_lock(&mutex);
      opCount++;
      pthread_mutex_unlock(&mutex); 

      pthread_mutex_lock(&mutex_2);
      lastInsert1 = id; 
      pthread_mutex_unlock(&mutex_2);



      pthread_mutex_lock(&mutex);
      if(opCount==3);
      pthread_mutex_unlock(&mutex);

      pthread_mutex_lock(&mutex);
      if(opCount==4);
      pthread_mutex_unlock(&mutex);

      pthread_mutex_lock(&mutex);
      if(opCount==5);
      pthread_mutex_unlock(&mutex); 

      sprintf(name1, "hello2");
      name1[strlen (name1) - 1] = '\0';	/* chop newline */
 
      cp_rbtree_insert (t, name1, name1);
      pthread_mutex_lock(&mutex);
      opCount++;
      pthread_mutex_unlock(&mutex); 


     
      pthread_mutex_lock(&mutex_2);
      lastInsert2 = id; 
      pthread_mutex_unlock(&mutex_2); 

    
      pthread_mutex_lock(&mutex_2);
      if(lastInsert1!= id);
      pthread_mutex_unlock(&mutex_2);
             

      sprintf(name1, "hello");
      name1[strlen (name1) - 1] = '\0';	

      cp_rbtree_delete (t, name1);
      pthread_mutex_lock(&mutex);
      opCount++;
      pthread_mutex_unlock(&mutex);

      pthread_mutex_lock(&mutex_2);
      if(lastInsert2!= id);
      pthread_mutex_unlock(&mutex_2);


      sprintf(name1, "hello2");
      name1[strlen (name1) - 1] = '\0';

      cp_rbtree_delete (t, name1);
      pthread_mutex_lock(&mutex);
      opCount++;
      pthread_mutex_unlock(&mutex);


      cp_rbtree_dump (t);


      pthread_exit(NULL);
 
}


int
main ()
{
  pthread_t t1, t2, t3;

  t = cp_rbtree_create_by_option(COLLECTION_MODE_COPY,
				    (cp_compare_fn) strcmp,
				    (cp_copy_fn) strdup, free,
				    (cp_copy_fn) strdup, free);

  if (t == NULL)
    {
      perror ("create");
      exit (1);
    }

  pthread_mutex_init(&(mutex), NULL);
  pthread_mutex_init(&(mutex_2), NULL);
  /*CREST_shared_int(opCount);
  CREST_shared_int(lastInsert1);
  CREST_shared_int(lastInsert2);*/
  klee_make_symbolic(&opCount, sizeof(opCount), "shared*opCount");
  klee_make_symbolic(&lastInsert1, sizeof(lastInsert1), "shared*lastInsert1");
  klee_make_symbolic(&lastInsert2, sizeof(lastInsert2), "shared*lastInsert2");


  printf("in main \n");
  pthread_create(&t1, NULL, thread_routine, (void*)1);
  pthread_create(&t2, NULL, thread_routine, (void*)2);
  //pthread_create(&t3, NULL, thread_routine, NULL);


  //pthread_join(t1, NULL);
  //pthread_join(t2, NULL);
  //pthread_join(t3, NULL);

  //cp_rbtree_destroy (t);

  pthread_exit(NULL);
  return 0;
}
